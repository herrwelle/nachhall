<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>Nachhall æ’­æ”¾ï¼ˆGriffin-Lim é‡å»ºï¼‰</title>
    <style>
        :root {
            color-scheme: dark;
        }

        html,
        body {
            margin: 0;
            height: 100%;
            background: #000;
            color: #fff;
            font-family: system-ui, -apple-system, Segoe UI;
        }

        #stage {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
        }

        video {
            max-width: 100vw;
            max-height: 100vh;
            display: block;
            opacity: .98;
        }

        #ui {
            position: fixed;
            inset: 0;
            pointer-events: none;
        }

        #frame {
            position: fixed;
            inset: 0;
            pointer-events: none;
        }

        .white {
            box-shadow: 0 0 0 3px rgba(255, 255, 255, .6) inset;
        }

        .green {
            box-shadow: 0 0 0 4px rgba(0, 255, 170, .95) inset;
        }

        #unlock {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, .55);
            backdrop-filter: blur(2px);
            cursor: pointer;
        }

        #unlock button {
            font-size: 18px;
            padding: 12px 18px;
            border-radius: 12px;
            border: 1px solid #9cf;
            background: #101b;
            color: #fff;
        }

        #log {
            position: fixed;
            left: 8px;
            top: 8px;
            font: 12px ui-monospace, Menlo, Consolas;
            color: #9cf;
            white-space: pre;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="stage">
        <video id="cam" playsinline autoplay muted></video>
    </div>
    <canvas id="ui"></canvas>
    <div id="frame" class="white"></div>
    <div id="unlock">
        <button>ğŸ”Š ç‚¹å‡»è§£é”å£°éŸ³å¹¶å¼€å§‹æ’­æ”¾</button>
    </div>
    <div id="log"></div>

    <script>
        /* ==== å‚æ•°ï¼ˆä¸ç¼–ç å™¨åŒ¹é…ï¼‰ ==== */
        const CAN_W = 1024, CAN_H = 640;
        const SPEC_X = 0, SPEC_Y = 0, SPEC_W = CAN_W, SPEC_H = CAN_H;
        const SR = 16000, DUR = 3.0, NFFT = 1024, HOP = 128, BINS = NFFT / 2 + 1, GL_ITERS = 28;

        /* ==== DOM å…ƒç´  ==== */
        const cam = document.getElementById('cam');
        const ui = document.getElementById('ui');
        const frame = document.getElementById('frame');
        const unlock = document.getElementById('unlock');
        const logbox = document.getElementById('log');

        let capCv = null, capCtx = null;
        let actx = null, source = null, buffer = null, startTime = 0, startOffset = 0, playing = false, unlocked = false;
        let frozen = null, building = false;

        function log(s) { logbox.textContent = s; }

        /* ==== å·¥å…·å‡½æ•° ==== */
        function grayAt(d, i) { return 0.2126 * d[i] + 0.7152 * d[i + 1] + 0.0722 * d[i + 2]; }

        function findCorners(img, W, H) {
            const data = img.data, th = 90, w3 = W / 3 | 0, h3 = H / 3 | 0;

            function best(x0, y0, w, h) {
                let best = { area: 0, cx: 0, cy: 0 };
                for (let y = y0; y < y0 + h; y += 2) {
                    for (let x = x0; x < x0 + w; x += 2) {
                        const i = (y * W + x) * 4, g = grayAt(data, i);
                        if (g < th) {
                            let area = 0, sx = 0, sy = 0;
                            for (let yy = y; yy < y + 12 && yy < H; yy += 2) {
                                for (let xx = x; xx < x + 12 && xx < W; xx += 2) {
                                    const ii = (yy * W + xx) * 4;
                                    if (grayAt(data, ii) < th) {
                                        area++; sx += xx; sy += yy;
                                    }
                                }
                            }
                            if (area > best.area) best = { area, cx: sx / area, cy: sy / area };
                        }
                    }
                }
                return best.area ? { x: best.cx, y: best.cy } : null;
            }

            const tl = best(0, 0, w3, h3);
            const tr = best(W - w3, 0, w3, h3);
            const bl = best(0, H - h3, w3, h3);
            const br = best(W - w3, H - h3, w3, h3);

            if (tl && tr && bl && br) return [tl, tr, bl, br];
            return null;
        }

        function solveHomography(p) {
            const [tl, tr, bl, br] = p;
            const s = [tl.x, tl.y, tr.x, tr.y, bl.x, bl.y, br.x, br.y];
            const d = [0, 0, CAN_W, 0, 0, CAN_H, CAN_W, CAN_H];
            const [x0, y0, x1, y1, x2, y2, x3, y3] = s;
            const [X0, Y0, X1, Y1, X2, Y2, X3, Y3] = d;

            const M = [
                x0, y0, 1, 0, 0, 0, -X0 * x0, -X0 * y0,
                0, 0, 0, x0, y0, 1, -Y0 * x0, -Y0 * y0,
                x1, y1, 1, 0, 0, 0, -X1 * x1, -X1 * y1,
                0, 0, 0, x1, y1, 1, -Y1 * x1, -Y1 * y1,
                x2, y2, 1, 0, 0, 0, -X2 * x2, -X2 * y2,
                0, 0, 0, x2, y2, 1, -Y2 * x2, -Y2 * y2,
                x3, y3, 1, 0, 0, 0, -X3 * x3, -X3 * y3,
                0, 0, 0, x3, y3, 1, -Y3 * x3, -Y3 * y3
            ];
            const B = [X0, Y0, X1, Y1, X2, Y2, X3, Y3];

            const A = new Float64Array(64), bb = new Float64Array(8);
            for (let i = 0; i < 64; i++) A[i] = M[i];
            for (let i = 0; i < 8; i++) bb[i] = B[i];

            // é«˜æ–¯æ¶ˆå…ƒ
            for (let i = 0; i < 8; i++) {
                let piv = i, pv = Math.abs(A[i * 8 + i]);
                for (let r = i + 1; r < 8; r++) {
                    const v = Math.abs(A[r * 8 + i]);
                    if (v > pv) { pv = v; piv = r; }
                }
                if (piv !== i) {
                    for (let c = i; c < 8; c++) {
                        [A[i * 8 + c], A[piv * 8 + c]] = [A[piv * 8 + c], A[i * 8 + c]];
                    }
                    [bb[i], bb[piv]] = [bb[piv], bb[i]];
                }
                const d0 = A[i * 8 + i];
                for (let c = i; c < 8; c++) A[i * 8 + c] /= d0;
                bb[i] /= d0;
                for (let r = 0; r < 8; r++) {
                    if (r !== i) {
                        const mul = A[r * 8 + i];
                        for (let c = i; c < 8; c++) A[r * 8 + c] -= mul * A[i * 8 + c];
                        bb[r] -= mul * bb[i];
                    }
                }
            }

            const h = new Float64Array(9);
            for (let i = 0; i < 8; i++) h[i] = bb[i];
            h[8] = 1;
            return h;
        }

        function warpToCanonical(srcImg, W0, H0, Hm) {
            const dst = new ImageData(CAN_W, CAN_H);
            const d = dst.data, s = srcImg.data;
            const a = Hm;
            const A = a[0], B = a[1], C = a[2], D = a[3], E = a[4], F = a[5], G = a[6], H = a[7], I = a[8];
            const det = A * (E * I - F * H) - B * (D * I - F * G) + C * (D * H - E * G);
            const inv = [
                (E * I - F * H) / det, (C * H - B * I) / det, (B * F - C * E) / det,
                (F * G - D * I) / det, (A * I - C * G) / det, (C * D - A * F) / det,
                (D * H - E * G) / det, (B * G - A * H) / det, (A * E - B * D) / det
            ];

            function bilinear(x, y) {
                const x0 = Math.floor(x), y0 = Math.floor(y);
                const x1 = Math.min(W0 - 1, x0 + 1), y1 = Math.min(H0 - 1, y0 + 1);
                const a = x - x0, b = y - y0;
                const i00 = (y0 * W0 + x0) * 4, i10 = (y0 * W0 + x1) * 4;
                const i01 = (y1 * W0 + x0) * 4, i11 = (y1 * W0 + x1) * 4;
                const r00 = s[i00], g00 = s[i00 + 1], b00 = s[i00 + 2];
                const r10 = s[i10], g10 = s[i10 + 1], b10 = s[i10 + 2];
                const r01 = s[i01], g01 = s[i01 + 1], b01 = s[i01 + 2];
                const r11 = s[i11], g11 = s[i11 + 1], b11 = s[i11 + 2];
                const r0 = r00 * (1 - a) + r10 * a, g0 = g00 * (1 - a) + g10 * a, b0 = b00 * (1 - a) + b10 * a;
                const r1 = r01 * (1 - a) + r11 * a, g1 = g01 * (1 - a) + g11 * a, b1 = b01 * (1 - a) + b11 * a;
                return [r0 * (1 - b) + r1 * b, g0 * (1 - b) + g1 * b, b0 * (1 - b) + b1 * b];
            }

            for (let y = 0; y < CAN_H; y++) {
                for (let x = 0; x < CAN_W; x++) {
                    const X = inv[0] * x + inv[1] * y + inv[2];
                    const Y = inv[3] * x + inv[4] * y + inv[5];
                    const Z = inv[6] * x + inv[7] * y + inv[8];
                    const sx = X / Z, sy = Y / Z;
                    const idx = (y * CAN_W + x) * 4;
                    if (sx >= 0 && sx < W0 && sy >= 0 && sy < H0) {
                        const [r, g, b] = bilinear(sx, sy);
                        d[idx] = r; d[idx + 1] = g; d[idx + 2] = b; d[idx + 3] = 255;
                    } else {
                        d[idx] = d[idx + 1] = d[idx + 2] = 0; d[idx + 3] = 255;
                    }
                }
            }
            return dst;
        }

        /* ==== å¢å¼ºé¢‘è°±æå– + ç‰¹å¾åˆ†æ ==== */
        function extractMagnitudeAuto(img) {
            const data = img.data;
            const frames = Math.floor((SR * DUR - NFFT) / HOP) + 1;
            const mags = new Float32Array(frames * BINS);

            // é‡‡æ ·å¯¹æ¯”åº¦
            const samp = [];
            for (let i = 0; i < 1500; i++) {
                const x = SPEC_X + (Math.random() * SPEC_W) | 0;
                const y = SPEC_Y + (Math.random() * SPEC_H) | 0;
                const idx = (y * CAN_W + x) * 4;
                samp.push(grayAt(data, idx));
            }
            samp.sort((a, b) => a - b);
            const p10 = samp[(samp.length * 0.10) | 0];
            const p90 = samp[(samp.length * 0.90) | 0];
            const den = Math.max(8, p90 - p10);

            // é»‘=å¼ºå‡è®¾ï¼Œä½†å¢å¼ºå¯¹æ¯”åº¦
            const mapBlack = g => {
                let val = Math.max(0, Math.min(1, 1 - (g - p10) / den));
                // å¢å¼ºå¯¹æ¯”åº¦ï¼šä½¿ç”¨å¹‚å‡½æ•°
                return Math.pow(val, 0.7); // æå‡ä¸­ç­‰å¼ºåº¦çš„ä¿¡å·
            };

            for (let f = 0; f < frames; f++) {
                const x = SPEC_X + Math.round(f * (SPEC_W - 1) / (frames - 1));
                for (let k = 0; k < BINS; k++) {
                    const y = SPEC_Y + Math.round((SPEC_H - 1) - k * (SPEC_H - 1) / (BINS - 1));
                    const idx = (y * CAN_W + x) * 4;
                    let a = mapBlack(grayAt(data, idx));

                    // é¢‘ç‡åŠ æƒï¼šå¢å¼ºäººå£°/åŠ¨ç‰©å£°éŸ³çš„å…³é”®é¢‘ç‡èŒƒå›´
                    const freq = (k / BINS) * (SR / 2);
                    let freqWeight = 1.0;

                    if (freq >= 200 && freq <= 1000) {
                        freqWeight = 1.5; // åŸºé¢‘èŒƒå›´å¢å¼º
                    } else if (freq >= 1000 && freq <= 3000) {
                        freqWeight = 1.3; // å…±æŒ¯å³°èŒƒå›´å¢å¼º
                    } else if (freq > 6000) {
                        freqWeight = 0.6; // é«˜é¢‘è¡°å‡ï¼Œå‡å°‘å™ªå£°
                    }

                    mags[f * BINS + k] = a * freqWeight;
                }
            }

            // æ›´æ¿€è¿›çš„å½’ä¸€åŒ–
            const sorted = Array.from(mags).sort((a, b) => a - b);
            const p90_val = sorted[(sorted.length * 0.90) | 0] || 1;
            const g = p90_val > 1e-6 ? (2.0 / p90_val) : 1.0; // å¢åŠ å¢ç›Š
            for (let i = 0; i < mags.length; i++) mags[i] *= g;

            // åˆ†æé¢‘è°±ç‰¹å¾ç”¨äºåç»­åˆæˆ
            const features = analyzeSpectralFeatures(mags, frames, BINS);

            return { mags, frames, features };
        }

        function analyzeSpectralFeatures(mags, frames, bins) {
            const features = {
                fundamentalFreq: 0,
                formants: [],
                energy: 0,
                spectralCentroid: 0
            };

            // è®¡ç®—å¹³å‡é¢‘è°±
            const avgSpectrum = new Float32Array(bins);
            for (let k = 0; k < bins; k++) {
                let sum = 0;
                for (let f = 0; f < frames; f++) {
                    sum += mags[f * bins + k];
                }
                avgSpectrum[k] = sum / frames;
            }

            // å¯»æ‰¾åŸºé¢‘ï¼ˆåœ¨åŠ¨ç‰©å£°éŸ³çš„å…¸å‹èŒƒå›´å†…ï¼‰
            let maxMag = 0;
            let maxBin = 0;
            const minF0Bin = Math.floor(150 * bins * 2 / SR); // 150Hz
            const maxF0Bin = Math.floor(800 * bins * 2 / SR); // 800Hz

            for (let k = minF0Bin; k < Math.min(maxF0Bin, bins); k++) {
                if (avgSpectrum[k] > maxMag) {
                    maxMag = avgSpectrum[k];
                    maxBin = k;
                }
            }

            if (maxMag > 0.1) {
                features.fundamentalFreq = (maxBin / bins) * (SR / 2);
            } else {
                features.fundamentalFreq = 300; // é»˜è®¤åŸºé¢‘
            }

            // å¯»æ‰¾å…±æŒ¯å³°
            const formantRanges = [
                [400, 1200],   // F1
                [1000, 2500],  // F2
                [2000, 4000]   // F3
            ];

            for (const [minF, maxF] of formantRanges) {
                const minBin = Math.floor(minF * bins * 2 / SR);
                const maxBin = Math.floor(maxF * bins * 2 / SR);

                let maxFormantMag = 0;
                let maxFormantBin = minBin;

                for (let k = minBin; k < Math.min(maxBin, bins); k++) {
                    if (avgSpectrum[k] > maxFormantMag) {
                        maxFormantMag = avgSpectrum[k];
                        maxFormantBin = k;
                    }
                }

                if (maxFormantMag > 0.05) {
                    const formantFreq = (maxFormantBin / bins) * (SR / 2);
                    features.formants.push(formantFreq);
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å…±æŒ¯å³°ï¼Œä½¿ç”¨é»˜è®¤å€¼
            if (features.formants.length === 0) {
                features.formants = [800, 1600, 2800];
            }

            // è®¡ç®—æ€»èƒ½é‡
            features.energy = avgSpectrum.reduce((sum, val) => sum + val * val, 0);

            // è®¡ç®—é¢‘è°±é‡å¿ƒ
            let weightedSum = 0;
            let totalWeight = 0;
            for (let k = 0; k < bins; k++) {
                const freq = (k / bins) * (SR / 2);
                weightedSum += freq * avgSpectrum[k];
                totalWeight += avgSpectrum[k];
            }
            features.spectralCentroid = totalWeight > 0 ? weightedSum / totalWeight : 1000;

            console.log('é¢‘è°±ç‰¹å¾åˆ†æ:', features);
            return features;
        }

        /* ==== FFT/IFFT ==== */
        function hann(N) {
            const w = new Float32Array(N);
            for (let n = 0; n < N; n++) w[n] = 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
            return w;
        }

        function fftRadix2(re, im) {
            const N = re.length;
            let j = 0;
            for (let i = 1; i < N - 1; i++) {
                let bit = N >> 1;
                for (; j & bit; bit >>= 1) j ^= bit;
                j ^= bit;
                if (i < j) {
                    [re[i], re[j]] = [re[j], re[i]];
                    [im[i], im[j]] = [im[j], im[i]];
                }
            }
            for (let len = 2; len <= N; len <<= 1) {
                const ang = -2 * Math.PI / len;
                const wlen_r = Math.cos(ang), wlen_i = Math.sin(ang);
                for (let i = 0; i < N; i += len) {
                    let wr = 1, wi = 0;
                    for (let k = 0; k < len / 2; k++) {
                        const u_r = re[i + k], u_i = im[i + k];
                        const v_r = re[i + k + len / 2] * wr - im[i + k + len / 2] * wi;
                        const v_i = re[i + k + len / 2] * wi + im[i + k + len / 2] * wr;
                        re[i + k] = u_r + v_r; im[i + k] = u_i + v_i;
                        re[i + k + len / 2] = u_r - v_r; im[i + k + len / 2] = u_i - v_i;
                        const nwr = wr * wlen_r - wi * wlen_i;
                        const nwi = wr * wlen_i + wi * wlen_r;
                        wr = nwr; wi = nwi;
                    }
                }
            }
        }

        function ifftRadix2(re, im) {
            for (let i = 0; i < re.length; i++) im[i] = -im[i];
            fftRadix2(re, im);
            const N = re.length;
            for (let i = 0; i < N; i++) { re[i] /= N; im[i] /= N; }
        }

        /* ==== æº-æ»¤æ³¢å™¨åˆæˆï¼ˆæ›¿ä»£Griffin-Limï¼‰ ==== */
        function sourceFilterSynthesis(mags, frames, features) {
            const outLen = SR * DUR; // 3ç§’éŸ³é¢‘
            const y = new Float32Array(outLen);

            const f0 = features.fundamentalFreq;
            const formants = features.formants;
            const energy = Math.sqrt(features.energy);

            console.log(`åˆæˆå‚æ•°: F0=${f0.toFixed(1)}Hz, å…±æŒ¯å³°=[${formants.map(f => f.toFixed(0)).join(',')}]Hz, èƒ½é‡=${energy.toFixed(3)}`);

            // ä¸ºæ¯ä¸€å¸§ç”ŸæˆéŸ³é¢‘
            const hopSamples = Math.floor(SR * HOP / SR); // æ¯å¸§å¯¹åº”çš„æ ·æœ¬æ•°

            for (let f = 0; f < frames; f++) {
                const frameStart = f * hopSamples;
                const frameEnd = Math.min(frameStart + hopSamples * 2, outLen); // é‡å 

                // æå–å½“å‰å¸§çš„é¢‘è°±
                const frameMags = new Float32Array(BINS);
                for (let k = 0; k < BINS; k++) {
                    frameMags[k] = mags[f * BINS + k];
                }

                // è®¡ç®—å½“å‰å¸§çš„èƒ½é‡
                const frameEnergy = frameMags.reduce((sum, val) => sum + val * val, 0);
                if (frameEnergy < 0.01) continue; // è·³è¿‡é™éŸ³å¸§

                // åŠ¨æ€è°ƒæ•´åŸºé¢‘ï¼ˆåŸºäºé¢‘è°±å³°å€¼ï¼‰
                let dynamicF0 = f0;
                let maxPeak = 0;
                let peakBin = 0;

                const f0MinBin = Math.floor(f0 * 0.7 * BINS * 2 / SR);
                const f0MaxBin = Math.floor(f0 * 1.5 * BINS * 2 / SR);

                for (let k = f0MinBin; k < Math.min(f0MaxBin, BINS); k++) {
                    if (frameMags[k] > maxPeak) {
                        maxPeak = frameMags[k];
                        peakBin = k;
                    }
                }

                if (maxPeak > 0.1) {
                    dynamicF0 = (peakBin / BINS) * (SR / 2);
                }

                // ç”Ÿæˆå½“å‰å¸§çš„éŸ³é¢‘
                for (let i = frameStart; i < frameEnd; i++) {
                    const t = i / SR;
                    const frameT = (i - frameStart) / SR;

                    // 1. å£°é—¨æ¿€åŠ±æºï¼ˆè°æ³¢åºåˆ—ï¼‰
                    let source = 0;
                    const numHarmonics = Math.floor((SR / 2) / dynamicF0);

                    for (let h = 1; h <= Math.min(numHarmonics, 12); h++) {
                        const harmFreq = dynamicF0 * h;
                        if (harmFreq > SR / 2) break;

                        // è°æ³¢å¹…åº¦ï¼šåŸºäºå®é™…é¢‘è°±æ•°æ®
                        const harmBin = Math.floor(harmFreq * BINS * 2 / SR);
                        const harmAmp = harmBin < BINS ? frameMags[harmBin] : 0;

                        if (harmAmp > 0.01) {
                            // æ·»åŠ è½»å¾®çš„é¢‘ç‡æŠ–åŠ¨æ¨¡æ‹Ÿè‡ªç„¶å˜åŒ–
                            const jitter = 1 + 0.02 * Math.sin(2 * Math.PI * 6 * t) * Math.random();
                            const phase = 2 * Math.PI * harmFreq * jitter * t;

                            // è°æ³¢è¡°å‡ï¼šé«˜æ¬¡è°æ³¢è‡ªç„¶è¡°å‡
                            const decay = Math.pow(h, -0.8);
                            source += harmAmp * decay * Math.sin(phase);
                        }
                    }

                    // 2. å£°é“æ»¤æ³¢ï¼ˆå…±æŒ¯å³°å¢å¼ºï¼‰
                    let filtered = source;
                    for (const formantFreq of formants) {
                        // ç®€åŒ–çš„å…±æŒ¯å³°æ»¤æ³¢ï¼šé«˜æ–¯å¢å¼º
                        const distance = Math.abs(dynamicF0 - formantFreq);
                        const bandwidth = formantFreq * 0.1; // 10%å¸¦å®½
                        const resonance = 1 + 0.5 * Math.exp(-Math.pow(distance / bandwidth, 2));
                        filtered *= resonance;
                    }

                    // 3. æ·»åŠ æ°”æµå™ªå£°
                    const noiseLevel = Math.sqrt(frameEnergy) * 0.08;
                    const noise = (Math.random() - 0.5) * 2 * noiseLevel;
                    // é«˜é€šæ»¤æ³¢å™ªå£°
                    const filteredNoise = noise * (1 - Math.exp(-frameT * 50));
                    filtered += filteredNoise;

                    // 4. åŒ…ç»œè°ƒåˆ¶
                    let envelope = 1.0;
                    const frameDuration = hopSamples / SR;

                    // å¿«é€Ÿæ”»å‡»
                    if (frameT < 0.005) {
                        envelope = frameT / 0.005;
                    }
                    // è‡ªç„¶è¡°å‡
                    else if (frameT > frameDuration * 0.7) {
                        const fadeStart = frameDuration * 0.7;
                        const fadeLength = frameDuration * 0.3;
                        envelope = Math.exp(-(frameT - fadeStart) / (fadeLength * 0.4));
                    }

                    // 5. åº”ç”¨æ€»ä½“éŸ³é‡
                    const volume = Math.sqrt(frameEnergy) * energy * 0.8;
                    filtered *= envelope * volume;

                    // 6. è½¯é™åˆ¶å’Œç´¯åŠ 
                    const sample = Math.tanh(filtered * 1.5) * 0.9;

                    // é‡å ç›¸åŠ 
                    if (i < outLen) {
                        const weight = (i - frameStart) < hopSamples ? 1.0 :
                            Math.exp(-(i - frameStart - hopSamples) / hopSamples);
                        y[i] += sample * weight;
                    }
                }
            }

            // æœ€ç»ˆå¤„ç†
            // å»ç›´æµ
            let mean = 0;
            for (let i = 0; i < y.length; i++) mean += y[i];
            mean /= y.length;
            for (let i = 0; i < y.length; i++) y[i] -= mean;

            // åŠ¨æ€èŒƒå›´å‹ç¼©
            let rms = 0;
            for (let i = 0; i < y.length; i++) rms += y[i] * y[i];
            rms = Math.sqrt(rms / y.length);

            const targetRMS = 0.3;
            const gain = rms > 1e-6 ? targetRMS / rms : 1.0;

            for (let i = 0; i < y.length; i++) {
                y[i] *= gain;
                // æœ€ç»ˆè½¯é™åˆ¶
                y[i] = Math.tanh(y[i] * 1.2) * 0.85;
            }

            console.log(`éŸ³é¢‘åˆæˆå®Œæˆ: é•¿åº¦=${y.length}æ ·æœ¬, RMS=${rms.toFixed(4)}, å¢ç›Š=${gain.toFixed(2)}`);
            return y;
        }

        /* ==== éŸ³é¢‘æ’­æ”¾ ==== */
        async function ensureAudio() {
            if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
            if (actx.state !== 'running') {
                try { await actx.resume(); } catch (_) { }
            }
            unlocked = (actx.state === 'running');
            unlock.style.display = unlocked ? 'none' : 'flex';
            return unlocked;
        }

        function playFrom(offsetSec) {
            if (!buffer) return;
            if (source) {
                try { source.stop(); } catch (_) { }
                source.disconnect();
            }
            source = actx.createBufferSource();
            source.buffer = buffer;
            source.connect(actx.destination);
            startTime = actx.currentTime;
            startOffset = Math.max(0, Math.min(buffer.duration, offsetSec || 0));
            source.start(0, startOffset);
            playing = true;
            source.onended = () => { playing = false; };
        }

        function currentU() {
            if (!buffer || !playing) return (startOffset || 0) / (buffer.duration || 1);
            const t = (actx.currentTime - startTime) + startOffset;
            return Math.max(0, Math.min(1, t / (buffer.duration || 1)));
        }

        /* ==== ä¸»å¾ªç¯ ==== */
        async function loop() {
            capCtx.drawImage(cam, 0, 0, capCv.width, capCv.height);
            const img = capCtx.getImageData(0, 0, capCv.width, capCv.height);

            if (!frozen && !building) {
                const cs = findCorners(img, capCv.width, capCv.height);
                if (cs) {
                    frame.className = 'green';
                    const Hm = solveHomography(cs);
                    frozen = warpToCanonical(img, capCv.width, capCv.height, Hm);
                    building = true;
                    log('å·²é”å®šï¼Œæ­£åœ¨æŠ½è°± + Griffin-Lim é‡å»ºâ€¦');

                    try {
                        const { mags, frames, features } = extractMagnitudeAuto(frozen);
                        await ensureAudio();
                        if (!unlocked) {
                            log('âš ï¸ éœ€è¦ç‚¹å‡»è§£é”å£°éŸ³');
                        } else {
                            // æº-æ»¤æ³¢å™¨åˆæˆ
                            const wave = sourceFilterSynthesis(mags, frames, features);
                            buffer = actx.createBuffer(1, wave.length, SR);
                            buffer.copyToChannel(wave, 0, 0);
                            log(`åˆæˆå®Œæˆï¼šF0=${features.fundamentalFreq.toFixed(1)}Hz\nå…±æŒ¯å³°=[${features.formants.map(f => f.toFixed(0)).join(',')}]Hz\nç‚¹å‡»å±å¹•æ’­æ”¾`);
                        }
                    } catch (e) {
                        console.error(e);
                        alert('é‡å»ºå¤±è´¥ï¼š' + e.message);
                        frozen = null;
                    } finally {
                        building = false;
                    }
                } else {
                    frame.className = 'white';
                    log('è¯·æŠŠå¸¦é»‘æ¡†çš„é¢‘è°±ç½®äºå–æ™¯å™¨å†…ï¼ˆå‡ºç°ç»¿è‰²è¾¹æ¡†å³é”å®šï¼‰');
                }
            }

            drawUI();
            requestAnimationFrame(loop);
        }

        /* ==== UI ç»˜åˆ¶ ==== */
        function drawUI() {
            ui.width = innerWidth;
            ui.height = innerHeight;
            const ctx = ui.getContext('2d');
            ctx.clearRect(0, 0, ui.width, ui.height);

            if (!buffer) return;

            const r = cam.getBoundingClientRect();
            const u = currentU();
            const x = Math.round(r.left + u * r.width);

            ctx.strokeStyle = 'rgba(255,255,255,.95)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, r.top);
            ctx.lineTo(x, r.bottom);
            ctx.stroke();
        }

        function pointerU(ev) {
            const r = cam.getBoundingClientRect();
            return Math.max(0, Math.min(1, (ev.clientX - r.left) / r.width));
        }

        let dragging = false;

        window.addEventListener('pointerdown', async ev => {
            if (!await ensureAudio()) return;
            if (buffer) {
                dragging = true;
                const u = pointerU(ev);
                playFrom(u * buffer.duration);
            }
        });

        window.addEventListener('pointermove', ev => {
            if (dragging && buffer) {
                const u = pointerU(ev);
                playFrom(u * buffer.duration);
            }
        });

        window.addEventListener('pointerup', () => { dragging = false; });

        unlock.addEventListener('click', async () => {
            await ensureAudio();
            if (buffer) playFrom(currentU() * buffer.duration);
        });

        /* ==== å¯åŠ¨ç›¸æœº ==== */
        (async () => {
            try {
                const s = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                cam.srcObject = s;
                await cam.play();
                capCv = document.createElement('canvas');
                capCv.width = cam.videoWidth || 1280;
                capCv.height = cam.videoHeight || 720;
                capCtx = capCv.getContext('2d', { willReadFrequently: true });
                log('è¯·æŠŠå¸¦é»‘æ¡†çš„é¢‘è°±ç½®äºå–æ™¯å™¨å†…ï¼ˆå‡ºç°ç»¿è‰²è¾¹æ¡†å³é”å®šï¼‰');
                requestAnimationFrame(loop);
            } catch (e) {
                alert('ç›¸æœºå¯åŠ¨å¤±è´¥ï¼šè¯·åœ¨ HTTPS ä¸‹å¹¶å…è®¸ç›¸æœºæƒé™');
                log('ç›¸æœºå¯åŠ¨å¤±è´¥ï¼š' + e.message);
            }
        })();
    </script>
</body>

</html>
