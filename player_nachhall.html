<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Nachhall æ’­æ”¾ï¼ˆå†»ç»“é¢‘è°± Â· Griffin-Lim Â· ä¸€é”®è§£é”ï¼‰</title>
<style>
  :root{color-scheme:dark}
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI}
  #stage{position:fixed;inset:0;display:grid;place-items:center}
  video{max-width:100vw;max-height:100vh;display:block;opacity:.98}
  #ui{position:fixed;inset:0;pointer-events:none}
  #frame{position:fixed;inset:0;pointer-events:none}
  .white{box-shadow:0 0 0 3px rgba(255,255,255,.6) inset}
  .green{box-shadow:0 0 0 4px rgba(0,255,170,.95) inset}
  #unlock{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
          background:rgba(0,0,0,.55);backdrop-filter:blur(2px);cursor:pointer}
  #unlock button{font-size:18px;padding:12px 18px;border-radius:12px;border:1px solid #9cf;background:#101b; color:#fff}
  #log{position:fixed;left:8px;top:8px;font:12px ui-monospace,Menlo,Consolas;color:#9cf;white-space:pre;pointer-events:none}
</style>
</head>
<body>
<div id="stage"><video id="cam" playsinline autoplay muted></video></div>
<canvas id="ui"></canvas>
<div id="frame" class="white"></div>
<div id="unlock"><button>ğŸ”Š ç‚¹ä¸€ä¸‹è§£é”å£°éŸ³ï¼ˆAudioContextï¼‰</button></div>
<div id="log"></div>

<script>
/* ==== è§„èŒƒå›¾ä¸å‚æ•°ï¼ˆä¸ä½ çš„ç¼–ç å›¾åŒ¹é…å³å¯ï¼šæ•´å¼ å›¾å°±æ˜¯é¢‘è°±ï¼‰ ==== */
const CAN_W=1024, CAN_H=640;
const SPEC_X=0, SPEC_Y=0, SPEC_W=CAN_W, SPEC_H=CAN_H;

const SR=16000, DUR=3.0, NFFT=1024, HOP=128, BINS=NFFT/2+1, GL_ITERS=28;

/* ==== ç›¸æœº ==== */
const cam=$('#cam'), ui=$('#ui'), frame=$('#frame'), unlock=$('#unlock'), logbox=$('#log');
let capCv=null, capCtx=null;

function $(s){ return document.querySelector(s); }
function log(s){ logbox.textContent = s; }

/* ==== å·¥å…·ï¼šäº®åº¦/è§’ç‚¹/å•åº”/é‡‡æ · ==== */
function grayAt(d,i){ return 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; }
function findCorners(img,W,H){
  const data=img.data, th=90, w3=W/3|0, h3=H/3|0;
  function best(x0,y0,w,h){
    let best={area:0,cx:0,cy:0};
    for(let y=y0;y<y0+h;y+=2){
      for(let x=x0;x<x0+w;x+=2){
        const i=(y*W+x)*4, g=grayAt(data,i);
        if(g<th){
          let area=0, sx=0, sy=0;
          for(let yy=y; yy<y+12 && yy<H; yy+=2)
            for(let xx=x; xx<x+12 && xx<W; xx+=2){
              const ii=(yy*W+xx)*4; if(grayAt(data,ii)<th){ area++; sx+=xx; sy+=yy; }
            }
          if(area>best.area) best={area,cx:sx/area,cy:sy/area};
        }
      }
    }
    return best.area? {x:best.cx,y:best.cy}: null;
  }
  const tl=best(0,0,w3,h3), tr=best(W-w3,0,w3,h3), bl=best(0,H-h3,w3,h3), br=best(W-w3,H-h3,w3,h3);
  if(tl&&tr&&bl&&br) return [tl,tr,bl,br];
  return null;
}
function solveHomography(p){
  const [tl,tr,bl,br]=p;
  const s=[tl.x,tl.y, tr.x,tr.y, bl.x,bl.y, br.x,br.y], d=[0,0, CAN_W,0, 0,CAN_H, CAN_W,CAN_H];
  const [x0,y0,x1,y1,x2,y2,x3,y3]=s, [X0,Y0,X1,Y1,X2,Y2,X3,Y3]=d;
  const M=[
    x0,y0,1, 0,0,0, -X0*x0,-X0*y0,
    0,0,0, x0,y0,1, -Y0*x0,-Y0*y0,
    x1,y1,1, 0,0,0, -X1*x1,-X1*y1,
    0,0,0, x1,y1,1, -Y1*x1,-Y1*y1,
    x2,y2,1, 0,0,0, -X2*x2,-X2*y2,
    0,0,0, x2,y2,1, -Y2*x2,-Y2*y2,
    x3,y3,1, 0,0,0, -X3*x3,-X3*y3,
    0,0,0, x3,y3,1, -Y3*x3,-Y3*y3
  ];
  const B=[X0,Y0,X1,Y1,X2,Y2,X3,Y3];
  const A=new Float64Array(64), bb=new Float64Array(8);
  for(let i=0;i<64;i++) A[i]=M[i]; for(let i=0;i<8;i++) bb[i]=B[i];
  for(let i=0;i<8;i++){
    let piv=i, pv=Math.abs(A[i*8+i]);
    for(let r=i+1;r<8;r++){ const v=Math.abs(A[r*8+i]); if(v>pv){pv=v;piv=r;} }
    if(piv!==i){ for(let c=i;c<8;c++){ [A[i*8+c],A[piv*8+c]]=[A[piv*8+c],A[i*8+c]]; } [bb[i],bb[piv]]=[bb[piv],bb[i]]; }
    const d0=A[i*8+i]; for(let c=i;c<8;c++) A[i*8+c]/=d0; bb[i]/=d0;
    for(let r=0;r<8;r++) if(r!==i){ const mul=A[r*8+i]; for(let c=i;c<8;c++) A[r*8+c]-=mul*A[i*8+c]; bb[r]-=mul*bb[i]; }
  }
  const h=new Float64Array(9); for(let i=0;i<8;i++) h[i]=bb[i]; h[8]=1; return h;
}
function warpToCanonical(srcImg,W0,H0,Hm){
  const dst=new ImageData(CAN_W,CAN_H), d=dst.data, s=srcImg.data;
  const a=Hm, A=a[0],B=a[1],C=a[2],D=a[3],E=a[4],F=a[5],G=a[6],H=a[7],I=a[8];
  const det=A*(E*I-F*H)-B*(D*I-F*G)+C*(D*H-E*G);
  const inv=[
    (E*I-F*H)/det, (C*H-B*I)/det, (B*F-C*E)/det,
    (F*G-D*I)/det, (A*I-C*G)/det, (C*D-A*F)/det,
    (D*H-E*G)/det, (B*G-A*H)/det, (A*E-B*D)/det
  ];
  function bilinear(x,y){
    const x0=Math.floor(x), y0=Math.floor(y), x1=Math.min(W0-1,x0+1), y1=Math.min(H0-1,y0+1);
    const a=x-x0, b=y-y0;
    const i00=(y0*W0+x0)*4, i10=(y0*W0+x1)*4, i01=(y1*W0+x0)*4, i11=(y1*W0+x1)*4;
    const r00=s[i00],g00=s[i00+1],b00=s[i00+2], r10=s[i10],g10=s[i10+1],b10=s[i10+2];
    const r01=s[i01],g01=s[i01+1],b01=s[i01+2], r11=s[i11],g11=s[i11+1],b11=s[i11+2];
    const r0=r00*(1-a)+r10*a, g0=g00*(1-a)+g10*a, b0=b00*(1-a)+b10*a;
    const r1=r01*(1-a)+r11*a, g1=g01*(1-a)+g11*a, b1=b01*(1-a)+b11*a;
    return [ r0*(1-b)+r1*b, g0*(1-b)+g1*b, b0*(1-b)+b1*b ];
  }
  for(let y=0;y<CAN_H;y++){
    for(let x=0;x<CAN_W;x++){
      const X=inv[0]*x+inv[1]*y+inv[2], Y=inv[3]*x+inv[4]*y+inv[5], Z=inv[6]*x+inv[7]*y+inv[8];
      const sx=X/Z, sy=Y/Z, idx=(y*CAN_W+x)*4;
      if(sx>=0&&sx<W0&&sy>=0&&sy<H0){
        const [r,g,b]=bilinear(sx,sy);
        d[idx]=r; d[idx+1]=g; d[idx+2]=b; d[idx+3]=255;
      }else{ d[idx]=d[idx+1]=d[idx+2]=0; d[idx+3]=255; }
    }
  }
  return dst;
}

/* ==== æŠ½è°±ï¼ˆè‡ªé€‚åº”ææ€§ + å¢ç›Šå½’ä¸€ï¼‰ ==== */
function extractMagnitudeAuto(img){
  const data=img.data;
  const frames=Math.floor((SR*DUR - NFFT)/HOP)+1;
  const magsB=new Float32Array(frames*BINS); // å‡è®¾ é»‘=å¼º
  const magsW=new Float32Array(frames*BINS); // å‡è®¾ ç™½=å¼º
  // 10%/90% åˆ†ä½çš„å¯¹æ¯”åº¦æ‹‰ä¼¸ï¼ˆåœ¨è°±åŒºåŸŸé‡‡æ ·ï¼‰
  const samp=[];
  for(let i=0;i<1500;i++){
    const x=SPEC_X + (Math.random()*SPEC_W)|0;
    const y=SPEC_Y + (Math.random()*SPEC_H)|0;
    const idx=(y*CAN_W+x)*4; samp.push( grayAt(data,idx) );
  }
  samp.sort((a,b)=>a-b);
  const p10=samp[(samp.length*0.10)|0], p90=samp[(samp.length*0.90)|0], den=Math.max(8,p90-p10);
  const mapBlack=g=>Math.max(0,Math.min(1, 1 - (g-p10)/den)); // é»‘â†’1
  const mapWhite=g=>Math.max(0,Math.min(1, (g-p10)/den));      // ç™½â†’1

  function fillMags(mags, mapper){
    for(let f=0; f<frames; f++){
      const x = SPEC_X + Math.round(f*(SPEC_W-1)/(frames-1));
      for(let k=0; k<BINS; k++){
        const y = SPEC_Y + Math.round((SPEC_H-1) - k*(SPEC_H-1)/(BINS-1));
        const idx=(y*CAN_W + x)*4;
        let a = mapper( grayAt(data,idx) );
        // è½»åº¦é«˜é¢‘æŠ‘åˆ¶ï¼ˆå‡å°‘ç”µå­å‘³ï¼‰
        const hf = k/(BINS-1);
        a *= (hf<0.85)? 1.0 : (1.0 - (hf-0.85)/0.15*0.25);
        mags[f*BINS + k] = a;
      }
    }
  }
  fillMags(magsB, mapBlack);
  fillMags(magsW, mapWhite);

  // é€‰èƒ½é‡è¾ƒå¤§çš„å‡è®¾
  function energy(m){ let s=0; for(let i=0;i<m.length;i++) s+=m[i]; return s; }
  let mags = magsB, pol = "black=strong";
  if(energy(magsW) > energy(magsB)*1.05) { mags=magsW; pol="white=strong"; }

  // å½’ä¸€ï¼šæŒ‰ 95 åˆ†ä½ç¼©æ”¾åˆ° ~1.0ï¼Œé¿å…å¤ªå°/å¤ªå¤§
  const sorted = Array.from(mags).sort((a,b)=>a-b);
  const p95 = sorted[(sorted.length*0.95)|0] || 1;
  const g = p95>1e-6? (1.0/p95) : 1.0;
  for(let i=0;i<mags.length;i++) mags[i]*=g;

  return {mags, frames, pol};
}

/* ==== FFT/IFFT/Hann ==== */
function hann(N){ const w=new Float32Array(N); for(let n=0;n<N;n++) w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); return w; }
function fftRadix2(re,im){
  const N=re.length; let j=0;
  for(let i=1;i<N-1;i++){ let bit=N>>1; for(; j & bit; bit>>=1) j^=bit; j^=bit; if(i<j){ [re[i],re[j]]=[re[j],re[i]]; [im[i],im[j]]=[im[j],im[i]]; } }
  for(let len=2; len<=N; len<<=1){
    const ang=-2*Math.PI/len, wlen_r=Math.cos(ang), wlen_i=Math.sin(ang);
    for(let i=0;i<N;i+=len){
      let wr=1, wi=0;
      for(let k=0;k<len/2;k++){
        const u_r=re[i+k], u_i=im[i+k];
        const v_r=re[i+k+len/2]*wr - im[i+k+len/2]*wi;
        const v_i=re[i+k+len/2]*wi + im[i+k+len/2]*wr;
        re[i+k]=u_r+v_r; im[i+k]=u_i+v_i;
        re[i+k+len/2]=u_r-v_r; im[i+k+len/2]=u_i-v_i;
        const nwr=wr*wlen_r - wi*wlen_i, nwi=wr*wlen_i + wi*wlen_r; wr=nwr; wi=nwi;
      }
    }
  }
}
function ifftRadix2(re,im){
  for(let i=0;i<re.length;i++) im[i] = -im[i]; fftRadix2(re,im);
  const N=re.length; for(let i=0;i<N;i++){ re[i]/=N; im[i]/=N; }
}

/* ==== Griffin-Limï¼ˆå¸¦çª—å¹³æ–¹å½’ä¸€ï¼‰ ==== */
function griffinLim(mags, frames){
  const win=hann(NFFT), hop=HOP, bins=BINS;
  const outLen=(frames-1)*hop+NFFT;
  // éšæœºç›¸ä½åˆå§‹åŒ–
  let Sre=new Float32Array(frames*bins), Sim=new Float32Array(frames*bins);
  for(let i=0;i<Sre.length;i++){
    const ph=Math.random()*2*Math.PI, m=mags[i];
    Sre[i]=m*Math.cos(ph); Sim[i]=m*Math.sin(ph);
  }
  function istft(SR,SI){
    const y=new Float32Array(outLen), wsum=new Float32Array(outLen);
    const fr=new Float32Array(NFFT), fi=new Float32Array(NFFT);
    for(let f=0; f<frames; f++){
      for(let k=0;k<bins;k++){ fr[k]=SR[f*bins+k]; fi[k]=SI[f*bins+k]; }
      for(let k=bins;k<NFFT;k++){ const kk=NFFT-k; fr[k]=fr[kk]; fi[k]=-fi[kk]; }
      ifftRadix2(fr,fi);
      const off=f*hop;
      for(let n=0;n<NFFT;n++){ const w=win[n], v=fr[n]*w; y[off+n]+=v; wsum[off+n]+=w*w; }
    }
    for(let i=0;i<outLen;i++){ const d=wsum[i]>1e-9?wsum[i]:1; y[i]/=d; }
    return y;
  }
  function stft(x){
    const SR2=new Float32Array(frames*bins), SI2=new Float32Array(frames*bins);
    const fr=new Float32Array(NFFT), fi=new Float32Array(NFFT);
    for(let f=0; f<frames; f++){
      const off=f*hop;
      for(let n=0;n<NFFT;n++){ fr[n]=(x[off+n]||0)*win[n]; fi[n]=0; }
      fftRadix2(fr,fi);
      for(let k=0;k<bins;k++){ SR2[f*bins+k]=fr[k]; SI2[f*bins+k]=fi[k]; }
    }
    return {SR2,SI2};
  }
  for(let it=0; it<GL_ITERS; it++){
    const y=istft(Sre,Sim);
    const {SR2,SI2}=stft(y);
    for(let i=0;i<Sre.length;i++){
      const r=SR2[i], j=SI2[i], mag=Math.hypot(r,j);
      if(mag>1e-8){ Sre[i]=mags[i]*r/mag; Sim[i]=mags[i]*j/mag; } else { Sre[i]=0; Sim[i]=0; }
    }
  }
  // æœ€ç»ˆ ISTFT
  let y=istft(Sre,Sim);
  // å»ç›´æµ + å³°å€¼å½’ä¸€
  let mean=0; for(let i=0;i<y.length;i++) mean+=y[i]; mean/=y.length;
  for(let i=0;i<y.length;i++) y[i]-=mean;
  let peak=1e-9; for(let i=0;i<y.length;i++) peak=Math.max(peak,Math.abs(y[i]));
  const g=0.98/peak; for(let i=0;i<y.length;i++) y[i]*=g;
  return y;
}

/* ==== éŸ³é¢‘æ’­æ”¾ï¼ˆéœ€è¦æ‰‹åŠ¿è§£é”ï¼‰ ==== */
let actx=null, source=null, buffer=null, startTime=0, startOffset=0, playing=false, unlocked=false;
async function ensureAudio(){
  if(!actx) actx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:SR});
  if(actx.state!=='running'){ try{ await actx.resume(); }catch(_){} }
  unlocked = (actx.state==='running');
  $('#unlock').style.display = unlocked ? 'none' : 'flex';
  return unlocked;
}
function playFrom(offsetSec){
  if(!buffer) return;
  if(source){ try{source.stop();}catch(_){ } source.disconnect(); }
  source=actx.createBufferSource(); source.buffer=buffer; source.connect(actx.destination);
  startTime=actx.currentTime; startOffset=Math.max(0, Math.min(buffer.duration, offsetSec||0));
  source.start(0, startOffset); playing=true;
  source.onended=()=>{ playing=false; };
}
function currentU(){
  if(!buffer || !playing) return (startOffset||0)/(buffer.duration||1);
  const t=(actx.currentTime - startTime) + startOffset;
  return Math.max(0,Math.min(1, t/(buffer.duration||1)));
}

/* ==== ä¸»å¾ªç¯ï¼šé”å®šä¸€æ¬¡ â†’ å†»ç»“ â†’ æŠ½è°±ï¼ˆè‡ªé€‚åº”ï¼‰â†’ GL â†’ ç”Ÿæˆ AudioBuffer ==== */
let frozen=null, building=false;
async function loop(){
  capCtx.drawImage(cam,0,0,capCv.width,capCv.height);
  const img=capCtx.getImageData(0,0,capCv.width,capCv.height);
  if(!frozen && !building){
    const cs=findCorners(img, capCv.width, capCv.height);
    if(cs){
      frame.className='green';
      const Hm=solveHomography(cs);
      frozen = warpToCanonical(img, capCv.width, capCv.height, Hm);
      building=true;
      log('å·²é”å®šï¼Œæ­£åœ¨æŠ½è°± + GL é‡å»ºâ€¦');
      try{
        const {mags,frames,pol}=extractMagnitudeAuto(frozen);
        await ensureAudio();
        if(!unlocked){ log('âš ï¸ éœ€è¦ç‚¹ä¸€ä¸‹è§£é”å£°éŸ³'); }
        // Griffin-Lim
        const wave = griffinLim(mags, frames);
        buffer = actx.createBuffer(1, wave.length, SR);
        buffer.copyToChannel(wave,0,0);
        log(`é‡å»ºå®Œæˆï¼šframes=${frames}, bins=${BINS}, ææ€§=${pol}\nç‚¹å‡»å±å¹•ä»»æ„ä½ç½®ï¼šå¼€å§‹/è½é’ˆ/å¿«è¿›`);
      }catch(e){
        console.error(e); alert('é‡å»ºå¤±è´¥ï¼š'+e.message);
        frozen=null;
      }finally{
        building=false;
      }
    }else{
      frame.className='white';
      log('è¯·æŠŠå¸¦é»‘æ¡†çš„é¢‘è°±ç½®äºå–æ™¯å™¨å†…ï¼ˆå‡ºç°ç»¿è‰²è¾¹æ¡†å³é”å®šï¼‰');
    }
  }
  drawUI();
  requestAnimationFrame(loop);
}

/* ==== UIï¼šæ’­æ”¾ç«–çº¿ + æ‰‹åŠ¿ ==== */
function drawUI(){
  ui.width=innerWidth; ui.height=innerHeight;
  const ctx=ui.getContext('2d'); ctx.clearRect(0,0,ui.width,ui.height);
  if(!buffer) return;
  const r=cam.getBoundingClientRect();
  const u=currentU(); const x=Math.round(r.left + u*r.width);
  ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x,r.top); ctx.lineTo(x,r.bottom); ctx.stroke();
}
function pointerU(ev){
  const r=cam.getBoundingClientRect();
  return Math.max(0, Math.min(1, (ev.clientX - r.left)/r.width ));
}
let dragging=false;
window.addEventListener('pointerdown', async ev=>{
  if(!await ensureAudio()) return; // å…ˆè§£é”
  if(buffer){
    dragging=true;
    const u=pointerU(ev);
    playFrom(u*buffer.duration);
  }
});
window.addEventListener('pointermove', ev=>{
  if(dragging && buffer){
    const u=pointerU(ev);
    playFrom(u*buffer.duration);
  }
});
window.addEventListener('pointerup', ()=>{ dragging=false; });

$('#unlock').addEventListener('click', async ()=>{
  await ensureAudio();
  if(buffer) playFrom(currentU()*buffer.duration);
});

/* ==== å¯åŠ¨ç›¸æœº ==== */
(async ()=>{
  try{
    const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment', width:{ideal:1280}, height:{ideal:720}}});
    cam.srcObject=s; await cam.play();
    capCv=document.createElement('canvas'); capCv.width=cam.videoWidth||1280; capCv.height=cam.videoHeight||720;
    capCtx=capCv.getContext('2d',{willReadFrequently:true});
    log('è¯·æŠŠå¸¦é»‘æ¡†çš„é¢‘è°±ç½®äºå–æ™¯å™¨å†…ï¼ˆå‡ºç°ç»¿è‰²è¾¹æ¡†å³é”å®šï¼‰');
    requestAnimationFrame(loop);
  }catch(e){
    alert('ç›¸æœºå¯åŠ¨å¤±è´¥ï¼šè¯·åœ¨ HTTPS ä¸‹å¹¶å…è®¸ç›¸æœºæƒé™'); 
    log('ç›¸æœºå¯åŠ¨å¤±è´¥ï¼š'+e.message);
  }
})();
</script>
</body>
</html>
