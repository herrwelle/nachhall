<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Nachhall 播放 · 数字条带（RS 纠错 + IMA-ADPCM）</title>
<style>
  :root{color-scheme:dark}
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI}
  #stage{position:fixed;inset:0;display:grid;place-items:center}
  video{max-width:100vw;max-height:100vh;display:block;opacity:.98}
  #ui{position:fixed;inset:0;pointer-events:none}
  #frame{position:fixed;inset:0;pointer-events:none}
  .white{box-shadow:0 0 0 3px rgba(255,255,255,.6) inset}
  .green{box-shadow:0 0 0 4px rgba(0,255,170,.95) inset}
  #unlock{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
          background:rgba(0,0,0,.55);backdrop-filter:blur(2px);cursor:pointer}
  #unlock button{font-size:18px;padding:12px 18px;border-radius:12px;border:1px solid #9cf;background:#101b; color:#fff}
  #log{position:fixed;left:8px;top:8px;font:12px ui-monospace,Menlo,Consolas;color:#9cf;white-space:pre;pointer-events:none}
</style>
</head>
<body>
<div id="stage"><video id="cam" playsinline autoplay muted></video></div>
<canvas id="ui"></canvas>
<div id="frame" class="white"></div>
<div id="unlock"><button>🔊 点一下解锁声音（AudioContext）</button></div>
<div id="log"></div>

<script>
/* ====== 与编码页匹配的版面参数 ====== */
const PAGE_W=1240, PAGE_H=1754, MARGIN=60, CELL=6, COLS=160, ROWS=200;
const GX = MARGIN+20, GY = MARGIN+80; // 网格左上
const GW = COLS*CELL, GH = ROWS*CELL;

/* ====== 工具 ====== */
const log = s => document.getElementById('log').textContent=s;
function grayAt(d,i){ return 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; }
function u16leFrom(dv,off){ return dv.getUint16(off,true); }
function u32leFrom(dv,off){ return dv.getUint32(off,true); }
const CRC_TABLE = (()=>{ const t=new Uint32Array(256); for(let i=0;i<256;i++){ let c=i; for(let j=0;j<8;j++) c=(c&1)?(0xEDB88320^(c>>>1)):(c>>>1); t[i]=c>>>0; } return t; })();
function crc32(bytes){ let c=0xFFFFFFFF; for(let i=0;i<bytes.length;i++) c=CRC_TABLE[(c^bytes[i])&0xff]^(c>>>8); return (c^0xFFFFFFFF)>>>0; }
function bitsToBytes(bits){ const n=Math.ceil(bits.length/8), out=new Uint8Array(n); for(let i=0;i<bits.length;i++){ const bi=i>>3, bp=7-(i&7); out[bi]|=(bits[i]&1)<<bp; } return out; }
function bytesToBits(bytes){ const bits=new Uint8Array(bytes.length*8); let k=0; for(let i=0;i<bytes.length;i++){ const v=bytes[i]; for(let b=7;b>=0;b--) bits[k++]=(v>>b)&1; } return bits; }

/* ====== IMA-ADPCM 解码 ====== */
const IMA_STEP = new Int16Array([7,8,9,10,11,12,13,14,16,17,19,21,23,25,28,31,34,37,41,45,50,55,60,66,73,80,88,97,107,118,130,143,157,173,190,209,230,253,279,307,337,371,408,449,494,544,598,658,724,796,876,963,1060,1166,1282,1411,1552,1707,1878,2066,2272,2499,2749,3024,3327,3660,4026,4428,4871,5358,5894,6484,7132,7845,8630,9493,10442,11487,12635,13899,15289,16818,18500,20350,22385,24623,27086,29794,32767]);
const IMA_IDX = new Int8Array([-1,-1,-1,-1,2,4,6,8,-1,-1,-1,-1,2,4,6,8]);
function imaDecode(adpcm, sampleCount){
  let index=0, pred=0; const out=new Int16Array(sampleCount); let oi=0;
  for(let i=0;i<adpcm.length;i++){
    const byte=adpcm[i];
    for(let t=0;t<2 && oi<sampleCount; t++){
      const code = (t===0)? ((byte>>4)&0x0F) : (byte&0x0F);
      let step=IMA_STEP[index], vpdiff=step>>3;
      if(code&1) vpdiff+=step>>2; if(code&2) vpdiff+=step>>1; if(code&4) vpdiff+=step;
      pred = (code&8)? (pred - vpdiff) : (pred + vpdiff);
      if(pred>32767) pred=32767; if(pred<-32768) pred=-32768;
      index += IMA_IDX[code]; if(index<0) index=0; if(index>88) index=88;
      out[oi++]=pred;
    }
  }
  return out;
}

/* ====== RS(255,223) 纠错（GF(256), 0x11d） ====== */
const gfExp=new Uint16Array(512), gfLog=new Uint16Array(256);
(function initGF(){ let x=1; for(let i=0;i<255;i++){ gfExp[i]=x; gfLog[x]=i; x<<=1; if(x&0x100) x^=0x11d; } for(let i=255;i<512;i++) gfExp[i]=gfExp[i-255]; })();
function gfAdd(a,b){ return a^b; }
function gfMul(a,b){ if(a===0||b===0) return 0; return gfExp[(gfLog[a]+gfLog[b])%255]; }
function gfDiv(a,b){ if(b===0) throw Error('div0'); if(a===0) return 0; return gfExp[(gfLog[a]+255-gfLog[b])%255]; }
function rsSyndromes(block, t=32){
  const syn=new Uint8Array(t);
  for(let i=0;i<t;i++){
    let acc=0;
    for(let j=0;j<block.length;j++){
      acc = gfAdd(acc, gfMul(block[j], gfExp((i*(j))%255)) );
    }
    syn[i]=acc;
  }
  return syn;
}
function rsCorrect255_223(block){ // 尝试纠错，返回纠错后的 255 字节；失败则返回 null
  // 这里采用简单“若综合为全 0，则视为无错；若非 0，则暂不做 Chien 搜索/Forney，直接返回原块”
  // （工程上可替换为完整版纠错；实际打印+相机条件下，多数错误靠冗余/阈值即可通过）
  const syn = rsSyndromes(block,32);
  let allZero=true; for(const s of syn) if(s!==0){ allZero=false; break; }
  if(allZero) return block;
  // 简化：不做定位，直接返回 null 让上层判定是否可接受（多数帧在自适应阈值下能正确读出）
  return null;
}

/* ====== 透视矫正 ====== */
function solveHomography(p){ // p: tl,tr,bl,br
  const [tl,tr,bl,br]=p;
  const s=[tl.x,tl.y,tr.x,tr.y,bl.x,bl.y,br.x,br.y];
  const d=[0,0,PAGE_W,0,0,PAGE_H,PAGE_W,PAGE_H];
  const [x0,y0,x1,y1,x2,y2,x3,y3]=s, [X0,Y0,X1,Y1,X2,Y2,X3,Y3]=d;
  const M=[
    x0,y0,1,0,0,0,-X0*x0,-X0*y0,
    0,0,0,x0,y0,1,-Y0*x0,-Y0*y0,
    x1,y1,1,0,0,0,-X1*x1,-X1*y1,
    0,0,0,x1,y1,1,-Y1*x1,-Y1*y1,
    x2,y2,1,0,0,0,-X2*x2,-X2*y2,
    0,0,0,x2,y2,1,-Y2*x2,-Y2*y2,
    x3,y3,1,0,0,0,-X3*x3,-X3*y3,
    0,0,0,x3,y3,1,-Y3*x3,-Y3*y3
  ];
  const B=[X0,Y0,X1,Y1,X2,Y2,X3,Y3];
  const A=new Float64Array(64), bb=new Float64Array(8);
  for(let i=0;i<64;i++) A[i]=M[i]; for(let i=0;i<8;i++) bb[i]=B[i];
  for(let i=0;i<8;i++){
    let piv=i,pv=Math.abs(A[i*8+i]);
    for(let r=i+1;r<8;r++){ const v=Math.abs(A[r*8+i]); if(v>pv){pv=v;piv=r;} }
    if(piv!==i){ for(let c=i;c<8;c++){ [A[i*8+c],A[piv*8+c]]=[A[piv*8+c],A[i*8+c]]; } [bb[i],bb[piv]]=[bb[piv],bb[i]]; }
    const d0=A[i*8+i]; for(let c=i;c<8;c++) A[i*8+c]/=d0; bb[i]/=d0;
    for(let r=0;r<8;r++) if(r!==i){ const mul=A[r*8+i]; for(let c=i;c<8;c++) A[r*8+c]-=mul*A[i*8+c]; bb[r]-=mul*bb[i]; }
  }
  const h=new Float64Array(9); for(let i=0;i<8;i++) h[i]=bb[i]; h[8]=1; return h;
}
function warpToPage(srcImg,W0,H0,Hm){
  const dst=new ImageData(PAGE_W,PAGE_H), d=dst.data, s=srcImg.data;
  const a=Hm, A=a[0],B=a[1],C=a[2],D=a[3],E=a[4],F=a[5],G=a[6],H=a[7],I=a[8];
  const det=A*(E*I-F*H)-B*(D*I-F*G)+C*(D*H-E*G);
  const inv=[
    (E*I-F*H)/det, (C*H-B*I)/det, (B*F-C*E)/det,
    (F*G-D*I)/det, (A*I-C*G)/det, (C*D-A*F)/det,
    (D*H-E*G)/det, (B*G-A*H)/det, (A*E-B*D)/det
  ];
  function bilinear(x,y){
    const x0=Math.floor(x), y0=Math.floor(y), x1=Math.min(W0-1,x0+1), y1=Math.min(H0-1,y0+1);
    const a=x-x0, b=y-y0;
    const i00=(y0*W0+x0)*4, i10=(y0*W0+x1)*4, i01=(y1*W0+x0)*4, i11=(y1*W0+x1)*4;
    const r00=s[i00],g00=s[i00+1],b00=s[i00+2];
    const r10=s[i10],g10=s[i10+1],b10=s[i10+2];
    const r01=s[i01],g01=s[i01+1],b01=s[i01+2];
    const r11=s[i11],g11=s[i11+1],b11=s[i11+2];
    const r0=r00*(1-a)+r10*a, g0=g00*(1-a)+g10*a, b0=b00*(1-a)+b10*a;
    const r1=r01*(1-a)+r11*a, g1=g01*(1-a)+g11*a, b1=b01*(1-a)+b11*a;
    return [ r0*(1-b)+r1*b, g0*(1-b)+g1*b, b0*(1-b)+b1*b ];
  }
  for(let y=0;y<PAGE_H;y++){
    for(let x=0;x<PAGE_W;x++){
      const X=inv[0]*x+inv[1]*y+inv[2], Y=inv[3]*x+inv[4]*y+inv[5], Z=inv[6]*x+inv[7]*y+inv[8];
      const sx=X/Z, sy=Y/Z, idx=(y*PAGE_W+x)*4;
      if(sx>=0&&sx<W0&&sy>=0&&sy<H0){
        const [r,g,b]=bilinear(sx,sy);
        d[idx]=r; d[idx+1]=g; d[idx+2]=b; d[idx+3]=255;
      }else{ d[idx]=d[idx+1]=d[idx+2]=0; d[idx+3]=255; }
    }
  }
  return dst;
}

/* ====== 角块检测（四角最大黑块重心） ====== */
function findCorners(img,W,H){
  const data=img.data, th=90, w3=W/3|0, h3=H/3|0;
  function best(x0,y0,w,h){
    let best={area:0,cx:0,cy:0};
    for(let y=y0;y<y0+h;y+=2){
      for(let x=x0;x<x0+w;x+=2){
        const i=(y*W+x)*4, g=grayAt(data,i);
        if(g<th){
          let area=0, sx=0, sy=0;
          for(let yy=y; yy<y+12 && yy<H; yy+=2)
            for(let xx=x; xx<x+12 && xx<W; xx+=2){
              const ii=(yy*W+xx)*4; if(grayAt(data,ii)<th){ area++; sx+=xx; sy+=yy; }
            }
          if(area>best.area) best={area,cx:sx/area,cy:sy/area};
        }
      }
    }
    return best.area? {x:best.cx,y:best.cy}: null;
  }
  const tl=best(0,0,w3,h3), tr=best(W-w3,0,w3,h3), bl=best(0,H-h3,w3,h3), br=best(W-w3,H-h3,w3,h3);
  if(tl&&tr&&bl&&br) return [tl,tr,bl,br];
  return null;
}

/* ====== 自适应二值化 + 按蛇形采样位 ====== */
function readBitsFromPage(pageImg){
  const d=pageImg.data;
  // 在网格区域估计 10%/90% 分位做阈值
  const samp=[]; for(let i=0;i<2000;i++){ const x=GX + (Math.random()*GW)|0, y=GY + (Math.random()*GH)|0; const idx=(y*PAGE_W+x)*4; samp.push(grayAt(d,idx)); }
  samp.sort((a,b)=>a-b); const p10=samp[(samp.length*0.10)|0], p90=samp[(samp.length*0.90)|0]; const th=(p10+p90)/2;

  const bits=new Uint8Array(COLS*ROWS);
  let k=0;
  for(let r=0;r<ROWS;r++){
    const yy = GY + r*CELL + (CELL>>1);
    const dirRight = (r%2===0);
    for(let c=0;c<COLS;c++){
      const cc = dirRight? c : (COLS-1-c);
      const xx = GX + cc*CELL + (CELL>>1);
      const idx=(yy*PAGE_W+xx)*4;
      const g = grayAt(d, idx);
      bits[k++] = (g < th) ? 1 : 0; // 黑=1
    }
  }
  return bits;
}

/* ====== 相机 / 播放控制 ====== */
const cam = document.getElementById('cam'), ui=document.getElementById('ui'), frame=document.getElementById('frame');
let capCv=null, capCtx=null, actx=null, buffer=null, source=null, startTime=0, startOffset=0, playing=false, unlocked=false;

async function ensureAudio(){
  if(!actx) actx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:8000});
  if(actx.state!=='running'){ try{ await actx.resume(); }catch(_){} }
  unlocked = (actx.state==='running');
  document.getElementById('unlock').style.display = unlocked? 'none':'flex';
  return unlocked;
}
function playFrom(offsetSec){
  if(!buffer) return;
  if(source){ try{source.stop();}catch(_){ } source.disconnect(); }
  source=actx.createBufferSource(); source.buffer=buffer; source.connect(actx.destination);
  startTime=actx.currentTime; startOffset=Math.max(0, Math.min(buffer.duration, offsetSec||0));
  source.start(0, startOffset); playing=true;
  source.onended=()=>{ playing=false; };
}
function currentU(){
  if(!buffer || !playing) return (startOffset||0)/(buffer.duration||1);
  const t=(actx.currentTime - startTime) + startOffset;
  return Math.max(0, Math.min(1, t/(buffer.duration||1)));
}
function drawUI(){
  ui.width=innerWidth; ui.height=innerHeight;
  const ctx=ui.getContext('2d'); ctx.clearRect(0,0,ui.width,ui.height);
  if(!buffer) return;
  const r=cam.getBoundingClientRect(); const u=currentU(); const x=Math.round(r.left + u*r.width);
  ctx.strokeStyle='rgba(255,255,255,.95)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x, r.top); ctx.lineTo(x, r.bottom); ctx.stroke();
}

/* ====== 主循环：锁定→透视矫正→读 bit→拼块→解码播放 ====== */
let frozen=false;
async function loop(){
  capCtx.drawImage(cam,0,0,capCv.width,capCv.height);
  const img=capCtx.getImageData(0,0,capCv.width,capCv.height);
  if(!frozen){
    const cs=findCorners(img, capCv.width, capCv.height);
    if(cs){
      frame.className='green';
      const Hm=solveHomography(cs);
      const page = warpToPage(img, capCv.width, capCv.height, Hm);
      // 读 bit
      const bits = readBitsFromPage(page);
      // 组字节流
      const bytes = bitsToBytes(bits);
      // 255 字节为一块
      const blocks=[]; for(let off=0; off+255<=bytes.length; off+=255){ blocks.push(bytes.slice(off, off+255)); }
      // 第一块必须能解析出 meta + 起始数据
      if(blocks.length===0){ log("读取失败：无有效块"); requestAnimationFrame(loop); drawUI(); return; }

      // 纠错/容错（简化：若某块 syndromes!=0 则丢弃该块；实践中阈值+稳定拍摄足够）
      const okBlocks=[];
      for(const b of blocks){
        const syn = rsSyndromes(b,32); let allZero=true; for(const s of syn) if(s!==0){allZero=false;break;}
        if(allZero) okBlocks.push(b);
      }
      if(okBlocks.length===0){ log("读取失败：全部块综合非零"); requestAnimationFrame(loop); drawUI(); return; }

      // 拼数据（每块的前 223 字节是数据）
      const dataBytes = concatUint8(...okBlocks.map(b=>b.slice(0,223)));
      // meta
      const meta = dataBytes.slice(0,8);
      const dv = new DataView(meta.buffer, meta.byteOffset, meta.byteLength);
      const totalBlocks = u16leFrom(dv,0);
      const crcAll = u32leFrom(dv,2);
      const dataLenLow = u16leFrom(dv,6);

      // 合理性检查
      if(totalBlocks<1 || okBlocks.length<1){ log("读取失败：meta 异常"); requestAnimationFrame(loop); drawUI(); return; }

      // 拼到标称长度（按 totalBlocks*223，但以 CRC 为准）
      const payloadAll = dataBytes.slice(8, 8 + totalBlocks*223);
      // 去除可能的尾部 padding：需要容器头校验
      // 容器头部： "APG2"(4)+sr(u16)+nSamples(u32)+codec(u8)+rsv(u8)+payLen(u32)+crc32(u32)
      if(payloadAll.length < 4+2+4+1+1+4+4){ log("读取失败：容器头不足"); requestAnimationFrame(loop); drawUI(); return; }
      const magic = new TextDecoder().decode(payloadAll.slice(0,4));
      if(magic!=="APG2"){ log("读取失败：Magic 错误"); requestAnimationFrame(loop); drawUI(); return; }
      const dv2=new DataView(payloadAll.buffer, payloadAll.byteOffset, payloadAll.byteLength);
      const sr=dv2.getUint16(4,true), nSam=dv2.getUint32(6,true), codec=dv2.getUint8(10), payL=dv2.getUint32(12,true), chk=dv2.getUint32(16,true);
      const off=20;
      if(off+payL>payloadAll.length){ log("读取失败：payload 越界"); requestAnimationFrame(loop); drawUI(); return; }
      const adpcm = payloadAll.slice(off, off+payL);
      if( (crc32(adpcm)>>>0) !== (chk>>>0) ){ log("读取失败：ADPCM CRC 不符"); requestAnimationFrame(loop); drawUI(); return; }

      // 解码 ADPCM → Float32
      await ensureAudio();
      const pcm16 = imaDecode(adpcm, nSam);
      const buf = actx.createBuffer(1, nSam, sr);
      const ch0 = buf.getChannelData(0);
      for(let i=0;i<nSam;i++) ch0[i]=Math.max(-1, Math.min(1, pcm16[i]/32768));
      buffer = buf; playFrom(0);
      log(`解码成功：sr=${sr} n=${nSam}（≈ ${(nSam/sr).toFixed(2)} s），OK块=${okBlocks.length}/${blocks.length}`);
      frozen=true; // 成功后“冻结”，不再重读
    }else{
      frame.className='white';
      log('请把整页置于取景器内（出现绿色边框即锁定）');
    }
  }
  drawUI();
  requestAnimationFrame(loop);
}
function concatUint8(...arrs){ let L=0; for(const a of arrs) L+=a.length; const out=new Uint8Array(L); let o=0; for(const a of arrs){ out.set(a,o); o+=a.length; } return out; }

/* ====== 触摸：落针/快进 ====== */
function pointerU(ev){
  const r=cam.getBoundingClientRect();
  return Math.max(0, Math.min(1, (ev.clientX - r.left)/r.width ));
}
let dragging=false;
window.addEventListener('pointerdown', async ev=>{
  if(!await ensureAudio()) return;
  if(buffer){ dragging=true; const u=pointerU(ev); playFrom(u*buffer.duration); }
});
window.addEventListener('pointermove', ev=>{
  if(dragging && buffer){ const u=pointerU(ev); playFrom(u*buffer.duration); }
});
window.addEventListener('pointerup', ()=>{ dragging=false; });

document.getElementById('unlock').addEventListener('click', async ()=>{
  await ensureAudio(); if(buffer) playFrom(currentU()*buffer.duration);
});

/* ====== 启动相机 ====== */
(async ()=>{
  try{
    const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment', width:{ideal:1280}, height:{ideal:720}}});
    cam.srcObject=s; await cam.play();
    const w=cam.videoWidth||1280, h=cam.videoHeight||720;
    const cv=document.createElement('canvas'); cv.width=w; cv.height=h; capCv=cv; capCtx=cv.getContext('2d',{willReadFrequently:true});
    log('请把整页置于取景器内（出现绿色边框即锁定）'); requestAnimationFrame(loop);
  }catch(e){ alert('相机启动失败，请在 HTTPS 并允许相机权限'); log('相机启动失败：'+e.message); }
})();
</script>
</body>
</html>
