<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
    <title>Nachhall · 扫描播放 (修复版)</title>
    <style>
        :root{color-scheme:dark}
        html,body{margin:0;height:100%;background:#000;color:#eaffff;font-family:system-ui,-apple-system,Segoe UI}
        #stage{position:fixed;inset:0;display:grid;place-items:center;background:#000}
        video{max-width:100vw;max-height:100vh;display:block;opacity:.98}
        #ui{position:fixed;left:0;top:0;width:100vw;height:100vh;pointer-events:none}
        #frame{position:fixed;inset:0;pointer-events:none}
        #info{position:fixed;top:10px;left:10px;font-size:12px;opacity:0.7;pointer-events:none;background:rgba(0,0,0,0.5);padding:5px;border-radius:3px}
        .white{box-shadow:0 0 0 3px rgba(255,255,255,.65) inset}
        .green{box-shadow:0 0 0 4px rgba(0,255,170,.95) inset}
    </style>
</head>
<body>
    <div id="stage">
        <video id="cam" playsinline autoplay muted></video>
    </div>
    <canvas id="ui"></canvas>
    <div id="frame" class="white"></div>
    <div id="info">等待检测频谱图...</div>

    <script>
        /* === 参数设置 === */
        const SR = 16000, NFFT = 1024, HOP = 512;
        const K = NFFT/2 + 1;           // 513
        const T = 500;                  // 500 帧
        const ENC_MARGIN = 160;         
        const CELLX = 3, CELLY = 3;
        const DBMIN = -80;              
        const GRID_W = 2*ENC_MARGIN + T*CELLX;
        const GRID_H = 2*ENC_MARGIN + K*CELLY;

        const cam = document.getElementById('cam');
        const ui = document.getElementById('ui');
        const frame = document.getElementById('frame');
        const info = document.getElementById('info');

        let capCv = null, capCtx = null;
        let lastRect = null, lastSeenTs = 0;
        let actx = null, buffer = null, source = null, playing = false, durSec = 0;
        let playStart = 0;

        /* ========== 相机启动 ========== */
        async function startCam() {
            const s = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' }
            });
            cam.srcObject = s;
            await cam.play();
            
            capCv = document.createElement('canvas');
            capCv.width = cam.videoWidth || 1280;
            capCv.height = cam.videoHeight || 720;
            capCtx = capCv.getContext('2d', { willReadFrequently: true });
        }

        function lumAt(d, i) { 
            return 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]; 
        }

        /* ========== 黑框检测 ========== */
        function findBlackRect(img, W, H) {
            const data = img.data;
            const thr = autoThreshold(data, W, H);
            const step = 3;
            const col = new Float32Array(W), row = new Float32Array(H);

            for(let x = 0; x < W; x++) {
                let dark = 0, tot = 0;
                for(let y = 0; y < H; y += step) {
                    const i = (y*W + x)*4;
                    if(lumAt(data, i) < thr) dark++;
                    tot++;
                }
                col[x] = dark / Math.max(1, tot);
            }

            for(let y = 0; y < H; y++) {
                let dark = 0, tot = 0;
                for(let x = 0; x < W; x += step) {
                    const i = (y*W + x)*4;
                    if(lumAt(data, i) < thr) dark++;
                    tot++;
                }
                row[y] = dark / Math.max(1, tot);
            }

            const EDGE = 0.2;
            let xL = 0; while(xL < W && col[xL] < EDGE) xL++;
            let xR = W-1; while(xR >= 0 && col[xR] < EDGE) xR--;
            let yT = 0; while(yT < H && row[yT] < EDGE) yT++;
            let yB = H-1; while(yB >= 0 && row[yB] < EDGE) yB--;

            if(xR - xL < 100 || yB - yT < 100) return null;

            const ar = (xR - xL) / (yB - yT);
            if(ar < 0.3 || ar > 5.0) return null;

            return { sx: xL, sy: yT, sw: xR - xL + 1, sh: yB - yT + 1 };
        }

        function autoThreshold(data, W, H) {
            const N = 500, arr = new Float32Array(N);
            for(let i = 0; i < N; i++) {
                const x = (Math.random() * W) | 0;
                const y = (Math.random() * H) | 0;
                const idx = (y*W + x)*4;
                arr[i] = lumAt(data, idx);
            }
            arr.sort();
            const p = arr[(N * 0.3) | 0];
            return Math.max(30, Math.min(150, p));
        }

        /* ========== 采样频谱 ========== */
        function percentile(arr, p) {
            const i = Math.max(0, Math.min(arr.length-1, Math.floor(p*(arr.length-1))));
            return arr[i];
        }

        function sampleMFromRect(img, W, H, rect) {
            const data = img.data;
            const M = new Float32Array(K * T);
            
            const sX = rect.sw / GRID_W;
            const sY = rect.sh / GRID_H;
            
            // 简化的对比度计算
            const samp = [];
            for(let i = 0; i < 300; i++) {
                const gx = ENC_MARGIN + Math.random() * (T * CELLX);
                const gy = ENC_MARGIN + Math.random() * (K * CELLY);
                const px = rect.sx + sX * gx;
                const py = rect.sy + sY * gy;
                const xi = Math.max(0, Math.min(W-1, px|0));
                const yi = Math.max(0, Math.min(H-1, py|0));
                const idx = (yi*W + xi)*4;
                samp.push(lumAt(data, idx));
            }
            
            samp.sort((a,b) => a-b);
            const p10 = percentile(samp, 0.1);
            const p90 = percentile(samp, 0.9);
            const denom = Math.max(8, p90 - p10);
            
            // 简化采样
            for(let t = 0; t < T; t++) {
                const gx = ENC_MARGIN + t * CELLX + (CELLX >> 1);
                const px = rect.sx + sX * gx;
                
                for(let r = 0; r < K; r++) {
                    const gy = ENC_MARGIN + (K-1-r) * CELLY + (CELLY >> 1);
                    const py = rect.sy + sY * gy;
                    
                    const xi = Math.max(0, Math.min(W-1, px|0));
                    const yi = Math.max(0, Math.min(H-1, py|0));
                    const idx = (yi*W + xi)*4;
                    const lum = lumAt(data, idx);
                    
                    let norm = (p90 - lum) / denom;
                    norm = Math.max(0, Math.min(1, norm));
                    
                    const db = DBMIN + norm * (0 - DBMIN);
                    M[t*K + r] = Math.pow(10, db/20);
                }
            }
            
            return M;
        }

        /* ========== FFT ========== */
        function hann(N) { 
            const w = new Float32Array(N); 
            for(let n = 0; n < N; n++) 
                w[n] = 0.5 * (1 - Math.cos(2*Math.PI*n/(N-1))); 
            return w; 
        }

        const WIN = hann(NFFT);

        function makeFFT(N) {
            if(N & (N-1)) throw new Error('N must be pow2');
            
            const cos = new Float32Array(N/2), sin = new Float32Array(N/2);
            for(let i = 0; i < N/2; i++) { 
                const a = -2*Math.PI*i/N; 
                cos[i] = Math.cos(a); 
                sin[i] = Math.sin(a); 
            }
            
            const rev = new Uint32Array(N); 
            let b = 0; 
            while((1<<b) < N) b++;
            for(let i = 0; i < N; i++) { 
                let x = i, y = 0; 
                for(let j = 0; j < b; j++) { 
                    y = (y<<1) | (x&1); 
                    x >>= 1; 
                } 
                rev[i] = y; 
            }
            
            function fft(re, im) {
                for(let i = 0; i < N; i++) { 
                    const j = rev[i]; 
                    if(j > i) { 
                        let t = re[i]; re[i] = re[j]; re[j] = t; 
                        t = im[i]; im[i] = im[j]; im[j] = t; 
                    } 
                }
                
                for(let len = 2; len <= N; len <<= 1) { 
                    const h = len >>> 1, step = N/len;
                    for(let i = 0; i < N; i += len) {
                        for(let k = 0; k < h; k++) {
                            const c = cos[k*step], s = sin[k*step];
                            const j = i+k, l = j+h;
                            const r = c*re[l] - s*im[l];
                            const ii = s*re[l] + c*im[l];
                            re[l] = re[j] - r; 
                            im[l] = im[j] - ii; 
                            re[j] += r; 
                            im[j] += ii;
                        }
                    }
                }
            }
            
            function ifft(re, im) { 
                for(let i = 0; i < N; i++) im[i] = -im[i]; 
                fft(re, im); 
                const inv = 1/N; 
                for(let i = 0; i < N; i++) { 
                    re[i] *= inv; 
                    im[i] *= -inv; 
                } 
            }
            
            return { fft, ifft };
        }

        const FFT = makeFFT(NFFT);     
   /* ========== 简化稳定的 Griffin-Lim ========== */
        async function griffinLim(M, iters = 25) {
            console.log('开始Griffin-Lim重建，迭代次数:', iters);
            
            const re = new Float32Array(NFFT), im = new Float32Array(NFFT);
            const re2 = new Float32Array(NFFT), im2 = new Float32Array(NFFT);
            
            // 随机相位初始化
            const phase = new Float32Array(K * T);
            for(let i = 0; i < phase.length; i++) {
                phase[i] = Math.random() * 2 * Math.PI;
            }
            
            // OLA 权重
            const L = (T-1) * HOP + NFFT;
            const y = new Float32Array(L);
            const wsum = new Float32Array(L);
            
            for(let t = 0; t < T; t++) {
                const off = t * HOP;
                for(let n = 0; n < NFFT; n++) { 
                    wsum[off + n] += WIN[n] * WIN[n]; 
                }
            }
            
            // 迭代
            for(let it = 0; it < iters; it++) {
                y.fill(0);
                
                // ISTFT
                for(let t = 0; t < T; t++) {
                    for(let k = 0; k < K; k++) { 
                        const mag = M[t*K + k]; 
                        re[k] = mag * Math.cos(phase[t*K + k]); 
                        im[k] = mag * Math.sin(phase[t*K + k]); 
                    }
                    
                    for(let k = K; k < NFFT; k++) { 
                        re[k] = 0; 
                        im[k] = 0; 
                    }
                    for(let k = 1; k < K-1; k++) { 
                        re[NFFT-k] = re[k]; 
                        im[NFFT-k] = -im[k]; 
                    }
                    
                    FFT.ifft(re, im);
                    
                    const off = t * HOP;
                    for(let n = 0; n < NFFT; n++) { 
                        y[off + n] += re[n] * WIN[n]; 
                    }
                }
                
                // OLA 归一化
                for(let i = 0; i < L; i++) { 
                    if(wsum[i] > 1e-9) y[i] /= wsum[i]; 
                }
                
                if(it < iters - 1) {
                    // STFT 更新相位
                    for(let t = 0; t < T; t++) {
                        const off = t * HOP;
                        for(let n = 0; n < NFFT; n++) { 
                            re2[n] = (y[off + n] || 0) * WIN[n]; 
                            im2[n] = 0; 
                        }
                        
                        FFT.fft(re2, im2);
                        
                        for(let k = 0; k < K; k++) {
                            phase[t*K + k] = Math.atan2(im2[k], re2[k]);
                        }
                    }
                }
                
                // 进度更新
                if(it % 5 === 0) {
                    const progress = Math.round(it/iters*100);
                    info.textContent = `重建音频中... ${progress}%`;
                    console.log(`Griffin-Lim进度: ${progress}%`);
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            
            // 后处理
            let peak = 1e-9; 
            for(let i = 0; i < y.length; i++) 
                peak = Math.max(peak, Math.abs(y[i]));
            
            if(peak > 0) {
                const g = 0.8 / peak; 
                for(let i = 0; i < y.length; i++) {
                    y[i] = Math.tanh(y[i] * g) * 0.7;
                }
            }
            
            console.log('Griffin-Lim完成，音频长度:', y.length, '采样');
            return y;
        }

        /* ========== 播放控制 ========== */
        function stopSource() { 
            try { 
                if(source) {
                    source.stop(0);
                    source.disconnect();
                }
            } catch(e) {
                console.log('停止音源时出错:', e);
            } 
            source = null; 
            playing = false; 
        }

        async function ensureAudio() {
            if(!actx) {
                actx = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SR
                });
            }
            if(actx.state === 'suspended') { 
                try { 
                    await actx.resume(); 
                } catch(e) {
                    console.log('恢复音频上下文失败:', e);
                } 
            }
            return actx.state === 'running';
        }

        function playBuffer(y) {
            console.log('开始播放音频，长度:', y.length);
            stopSource();
            
            const buf = actx.createBuffer(1, y.length, SR);
            buf.getChannelData(0).set(y);
            buffer = buf; 
            durSec = y.length / SR;
            
            source = actx.createBufferSource();
            source.buffer = buffer; 
            source.loop = true;
            source.connect(actx.destination);
            
            playStart = actx.currentTime;
            source.start(0);
            playing = true;
            
            console.log('音频开始播放，时长:', durSec.toFixed(2), '秒');
            info.textContent = `播放中 (${durSec.toFixed(1)}s)`;
        }

        /* ========== 主循环 ========== */
        let debounceRebuild = 0;
        
        async function loop() {
            const W = capCv.width, H = capCv.height;
            capCtx.drawImage(cam, 0, 0, W, H);
            const img = capCtx.getImageData(0, 0, W, H);
            const rect = findBlackRect(img, W, H);
            const now = performance.now();
            const hasRect = !!rect;
            
            if(hasRect) { 
                lastSeenTs = now; 
                frame.className = 'green'; 
            } else { 
                frame.className = 'white'; 
            }
            
            if(hasRect) {
                const moved = !lastRect || 
                    Math.abs(rect.sx - lastRect.sx) > 10 || 
                    Math.abs(rect.sy - lastRect.sy) > 10 || 
                    Math.abs(rect.sw - lastRect.sw) > 15 || 
                    Math.abs(rect.sh - lastRect.sh) > 15;
                
                lastRect = rect;
                
                if(moved || (now - debounceRebuild > 3000) || !playing) {
                    debounceRebuild = now;
                    if(await ensureAudio()) {
                        console.log('检测到频谱图变化，开始重建');
                        info.textContent = '检测到频谱图，开始采样...';
                        
                        try {
                            const M = sampleMFromRect(img, W, H, rect);
                            console.log('频谱采样完成');
                            const y = await griffinLim(M, 25);
                            playBuffer(y);
                        } catch(e) {
                            console.error('音频重建失败:', e);
                            info.textContent = '音频重建失败';
                        }
                    }
                }
            } else {
                if(playing && now - lastSeenTs > 1000) { 
                    console.log('频谱图丢失，停止播放');
                    stopSource(); 
                    info.textContent = '频谱图丢失，播放暂停';
                }
            }
            
            drawUIOverlay(rect);
            requestAnimationFrame(loop);
        }

        /* ========== 修复的播放头显示 ========== */
        function drawUIOverlay(rect) {
            const ctx = ui.getContext('2d');
            const W = ui.width = innerWidth;
            const H = ui.height = innerHeight;
            ctx.clearRect(0, 0, W, H);
            
            if(!playing || !buffer || !rect || !actx) return;
            
            try {
                // 修复的时间计算
                const now = actx.currentTime;
                const elapsed = now - playStart;
                const progress = (elapsed % durSec) / durSec;  // 0 到 1
                const col = Math.floor(progress * T) % T;  // 0 到 T-1，确保循环
                
                // 坐标转换
                const vRect = cam.getBoundingClientRect();
                const sx = vRect.width / capCv.width;
                const sy = vRect.height / capCv.height;
                const ox = vRect.left, oy = vRect.top;
                
                const sX = rect.sw / GRID_W;
                const gx = ENC_MARGIN + col * CELLX + (CELLX >> 1);
                const px = rect.sx + sX * gx;
                
                const screenX = Math.round(ox + px * sx);
                
                // 绘制播放头
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX, oy);
                ctx.lineTo(screenX, oy + vRect.height);
                ctx.stroke();
                
                // 显示进度
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = '11px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${(progress*100).toFixed(0)}%`, screenX, oy + 12);
                
            } catch(e) {
                console.log('绘制播放头时出错:', e);
            }
        }

        /* ========== 启动 ========== */
        (async () => {
            try {
                info.textContent = '启动相机中...';
                await startCam();
                info.textContent = '相机就绪，请对准频谱图';
                console.log('相机启动成功');
                loop();
            } catch(e) {
                info.textContent = '相机启动失败：请在 HTTPS 下访问并允许相机权限';
                console.error('相机启动失败:', e);
            }
        })();
    </script>
</body>
</html>