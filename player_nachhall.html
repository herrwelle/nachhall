<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Nachhall · 扫描播放</title>
<style>
  :root{color-scheme:dark}
  html,body{margin:0;height:100%;background:#000;color:#eaffff;font-family:system-ui,-apple-system,Segoe UI}
  #stage{position:fixed;inset:0;display:grid;place-items:center;background:#000}
  video,canvas{max-width:100vw;max-height:100vh}
  #cam{display:block;opacity:.95}
  #view{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);image-rendering:pixelated;display:none}
  #frame{position:fixed;inset:0;pointer-events:none}
  .white{box-shadow:0 0 0 3px rgba(255,255,255,.65) inset}
  .green{box-shadow:0 0 0 4px rgba(0,255,170,.9) inset}
  .pulse{animation:pulse 1.6s ease-in-out infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 2px rgba(255,255,255,.25) inset}50%{box-shadow:0 0 0 6px rgba(255,255,255,.55) inset}100%{box-shadow:0 0 0 2px rgba(255,255,255,.25) inset}}
  .icons{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:18vw;opacity:.92;pointer-events:none}
  .arr{width:min(22vw,140px);height:auto;opacity:.75;filter:drop-shadow(0 0 10px #000)}
  .fadeOut{animation:fade 1s ease forwards}
  @keyframes fade{to{opacity:0;visibility:hidden}}
</style>
</head>
<body>
<div id="stage">
  <video id="cam" playsinline autoplay muted></video>
  <canvas id="view"></canvas>
</div>
<div id="frame" class="white pulse"></div>

<!-- 半透明左右箭头（5s 后淡出） -->
<div id="icons" class="icons">
  <svg class="arr" viewBox="0 0 128 128"><path fill="currentColor" d="M82 18L34 64l48 46v-26l-22-20 22-20z"/></svg>
  <svg class="arr" viewBox="0 0 128 128" style="transform:scaleX(-1)"><path fill="currentColor" d="M82 18L34 64l48 46v-26l-22-20 22-20z"/></svg>
</div>

<script>
/* —— 固定参数（与编码页一致） —— */
const SR=16000,NFFT=1024,HOP=512,K=NFFT/2+1,CELLX=3,CELLY=3,MARGIN=20,DBMIN=-80;

/* ========== 相机取景与“软锁定” ========== */
const cam=document.getElementById('cam');
const view=document.getElementById('view');
const frame=document.getElementById('frame');
const icons=document.getElementById('icons');

let capCv=null, capCtx=null;
let locked=false, stableCnt=0, lastRect=null;

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

async function startCam(){
  const s = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
  cam.srcObject=s; await cam.play();
  // 取原生尺寸，避免变形
  capCv=document.createElement('canvas');
  capCv.width=cam.videoWidth||1280; capCv.height=cam.videoHeight||720;
  capCtx=capCv.getContext('2d',{willReadFrequently:true});
}

function lumAt(d,i){ return 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; }

/* 找黑框（快速投影法） */
function findBlackRect(img,W,H){
  const data=img.data;
  const samples=512, vals=new Float32Array(samples);
  for(let i=0;i<samples;i++){ const x=(i*37)%W,y=(i*61)%H,idx=(y*W+x)*4; vals[i]=lumAt(data,idx); }
  vals.sort(); const thr=Math.max(40,Math.min(140,vals[(samples*0.2)|0]-10));
  const step=2, col=new Float32Array(W), row=new Float32Array(H);
  for(let x=0;x<W;x++){ let dark=0,tot=0; for(let y=0;y<H;y+=step){ const i=(y*W+x)*4; if(lumAt(data,i)<thr) dark++; tot++; } col[x]=dark/Math.max(1,tot); }
  for(let y=0;y<H;y++){ let dark=0,tot=0; for(let x=0;x<W;x+=step){ const i=(y*W+x)*4; if(lumAt(data,i)<thr) dark++; tot++; } row[y]=dark/Math.max(1,tot); }
  function argmax(a,A,B){ let mi=A,mv=-1; for(let i=A;i<=B;i++){ if(a[i]>mv){mv=a[i];mi=i;} } return [mi,mv]; }
  const [xL,sL]=argmax(col,0,(W*0.4)|0);
  const [xR,sR]=argmax(col,(W*0.6)|0,W-1);
  const [yT,sT]=argmax(row,0,(H*0.4)|0);
  const [yB,sB]=argmax(row,(H*0.6)|0,H-1);
  if(sL<0.15||sR<0.15||sT<0.15||sB<0.15) return null;
  const sx=xL, sy=yT, sw=xR-xL+1, sh=yB-yT+1;
  if(sw<80||sh<80) return null;
  return {sx,sy,sw,sh};
}
function sameRect(a,b){ if(!a||!b) return false; const dx=Math.abs(a.sx-b.sx),dy=Math.abs(a.sy-b.sy),dw=Math.abs(a.sw-b.sw),dh=Math.abs(a.sh-b.sh); return dx<8&&dy<8&&dw<12&&dh<12; }

/* 把 ROI 采样为标准网格并“平铺显示”（保持像素风，避免变形） */
function drawSpectroFlat(rect){
  const T = Math.round((rect.sw - 2*MARGIN)/CELLX);
  const gridW = 2*MARGIN + T*CELLX;
  const gridH = 2*MARGIN + K*CELLY;
  view.width=gridW; view.height=gridH;
  const vctx=view.getContext('2d'); vctx.imageSmoothingEnabled=false;
  vctx.drawImage(capCv, rect.sx,rect.sy,rect.sw,rect.sh, 0,0, gridW,gridH);
  view.style.display='block';  // 相机仍在背后显示，不会黑屏
}

/* 实时取景循环：一直跑；达标时变绿并更新平铺图 */
async function loop(){
  const W=capCv.width,H=capCv.height;
  capCtx.drawImage(cam,0,0,W,H);
  const img=capCtx.getImageData(0,0,W,H);
  const rect=findBlackRect(img,W,H);

  if(rect && sameRect(rect,lastRect)){ stableCnt++; } else { stableCnt=0; }
  lastRect=rect;

  if(rect){
    frame.className = (stableCnt>18) ? 'green' : 'white pulse';
    // 每帧都把最新 ROI 平铺到画面（用户能一直看到谱图），不会变形/拉伸
    drawSpectroFlat(rect);
    if(stableCnt===19){ // 第一次进入稳定：异步准备音频
      prepareAudioFromCanvas(view); // 不打断取景
      // 引导箭头 5 秒后淡出
      setTimeout(()=>icons.classList.add('fadeOut'), 5000);
    }
  }else{
    frame.className = 'white pulse';
    view.style.display='none';
    ybuf=null; T_all=0; // 失去目标时清空
  }
  requestAnimationFrame(loop);
}

/* ========== 频谱 → 音频（Griffin–Lim） ========== */
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function sampleMFromCanvas(cv){
  const ctx=cv.getContext('2d',{willReadFrequently:true});
  const W=cv.width,H=cv.height, data=ctx.getImageData(0,0,W,H).data;
  const T = Math.max(16, Math.round((W - 2*MARGIN)/CELLX));
  const M=new Float32Array(K*T);
  for(let t=0;t<T;t++){
    for(let r=0;r<K;r++){
      const cx=MARGIN + t*CELLX + (CELLX>>1);
      const cy=MARGIN + (K-1-r)*CELLY + (CELLY>>1);
      const idx=(cy*W+cx)*4;
      const lum=0.2126*data[idx]+0.7152*data[idx+1]+0.0722*data[idx+2];
      const norm=clamp(1 - lum/255, 0, 1);
      const db=DBMIN + norm*(0-DBMIN);
      M[t*K+r] = Math.pow(10, db/20);
    }
  }
  return {M,T};
}
function hann(N){ const w=new Float32Array(N); for(let n=0;n<N;n++) w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); return w; }
const WIN=hann(NFFT);
function makeFFT(N){
  if(N&(N-1)) throw new Error('N must be pow2');
  const cos=new Float32Array(N/2),sin=new Float32Array(N/2);
  for(let i=0;i<N/2;i++){ const a=-2*Math.PI*i/N; cos[i]=Math.cos(a); sin[i]=Math.sin(a); }
  const rev=new Uint32Array(N); let b=0; while((1<<b)<N) b++;
  for(let i=0;i<N;i++){ let x=i,y=0; for(let j=0;j<b;j++){ y=(y<<1)|(x&1); x>>=1; } rev[i]=y; }
  function fft(re,im){
    for(let i=0;i<N;i++){ const j=rev[i]; if(j>i){ let t=re[i]; re[i]=re[j]; re[j]=t; t=im[i]; im[i]=im[j]; im[j]=t; } }
    for(let len=2; len<=N; len<<=1){ const h=len>>>1, step=N/len;
      for(let i=0;i<N;i+=len) for(let k=0;k<h;k++){
        const c=cos[k*step], s=sin[k*step], j=i+k, l=j+h;
        const r=c*re[l]-s*im[l], ii=s*re[l]+c*im[l];
        re[l]=re[j]-r; im[l]=im[j]-ii; re[j]+=r; im[j]+=ii;
      }
    }
  }
  function ifft(re,im){ for(let i=0;i<N;i++) im[i]=-im[i]; fft(re,im); const inv=1/N; for(let i=0;i<N;i++){ re[i]*=inv; im[i]*=-im[i]; } }
  return {fft,ifft};
}
const FFT=makeFFT(NFFT);

async function griffinLimAsync(M, T, iter=8){
  const K=M.length/T, N=NFFT;
  const re=new Float32Array(N), im=new Float32Array(N);
  const re2=new Float32Array(N), im2=new Float32Array(N);
  const phase=new Float32Array(K*T); for(let i=0;i<phase.length;i++) phase[i]=Math.random()*2*Math.PI;
  const L=(T-1)*HOP + N; const y=new Float32Array(L);
  for(let it=0; it<iter; it++){
    y.fill(0);
    for(let t=0;t<T;t++){
      for(let k=0;k<K;k++){ const mag=M[t*K+k]; re[k]=mag*Math.cos(phase[t*K+k]); im[k]=mag*Math.sin(phase[t*K+k]); }
      for(let k=K;k<N;k++){ re[k]=0; im[k]=0; }
      for(let k=1;k<K-1;k++){ re[N-k]=re[k]; im[N-k]=-im[k]; }
      FFT.ifft(re,im);
      const off=t*HOP; for(let n=0;n<N;n++) y[off+n]+=re[n]*WIN[n];
    }
    if(it<iter-1){
      for(let t=0;t<T;t++){
        const off=t*HOP; for(let n=0;n<N;n++){ re2[n]=(y[off+n]||0)*WIN[n]; im2[n]=0; }
        FFT.fft(re2,im2); for(let k=0;k<K;k++) phase[t*K+k]=Math.atan2(im2[k],re2[k]);
      }
    }
    await sleep(0); // 让 UI 呼吸
  }
  // 轻限幅，去颗粒尖峰
  let peak=1e-9; for(let i=0;i<y.length;i++) peak=Math.max(peak,Math.abs(y[i]));
  const g=0.85/peak; for(let i=0;i<y.length;i++) y[i]=Math.tanh(y[i]*g);
  return y;
}

/* ========== 音频输出 + “原速咬合” ========== */
const audio = {
  ctx:null, node:null, mode:'worklet',
  async ensure(){
    if(this.ctx) return;
    this.ctx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:SR});
    try{
      const code = `
        class ScrubPlayer extends AudioWorkletProcessor{
          constructor(){ super(); this.buf=null; this.N=0; this.pos=0; this.target=0; this.down=false; this.snap=false;
            this.vNom=0; this.port.onmessage=e=>{const m=e.data;
              if(m.t==='init'){ this.buf=m.buf; this.N=this.buf.length; this.pos=this.target=m.start||0; this.vNom=m.vNom||0; }
              else if(m.t==='pos'){ this.target=Math.max(0,Math.min(this.N-1,m.p)); this.snap=false; }
              else if(m.t==='needle'){ this.down=!!m.d; }
              else if(m.t==='snap'){ this.snap=!!m.on; }
            }}
          process(_,outs){
            const out=outs[0][0];
            if(!this.buf || !this.down){ out.fill(0); return true; }
            let p=this.pos;
            if(this.snap && this.vNom>0){
              // 原速推进（轻微噪声抑制）
              const step=this.vNom; // 每样本推进量
              for(let n=0;n<out.length;n++){
                p += step;
                const i0=p|0,i1=Math.min(this.N-1,i0+1),a=p-i0;
                out[n]=Math.tanh((this.buf[i0]*(1-a)+this.buf[i1]*a)*0.9);
              }
            }else{
              // 自由刮盘：线性往 target 过渡
              const d=(this.target - p)/out.length;
              for(let n=0;n<out.length;n++){
                p += d;
                const i0=p|0,i1=Math.min(this.N-1,i0+1),a=p-i0;
                out[n]=Math.tanh((this.buf[i0]*(1-a)+this.buf[i1]*a)*0.9);
              }
            }
            this.pos=p; return true;
          }
        }
        registerProcessor('scrub-player',ScrubPlayer);
      `;
      const blob=new Blob([code],{type:'application/javascript'});
      const url=URL.createObjectURL(blob);
      await this.ctx.audioWorklet.addModule(url);
      URL.revokeObjectURL(url);
      this.node = new AudioWorkletNode(this.ctx,'scrub-player',{numberOfInputs:0,numberOfOutputs:1,outputChannelCount:[1]});
      this.node.connect(this.ctx.destination);
    }catch(e){
      // 兜底 ScriptProcessor（省略，移动端基本可用 Worklet）
      console.warn('Worklet init failed, audio may degrade.');
    }
  },
  async start(buf,startPos,vNom){
    await this.ensure();
    this.node.port.postMessage({t:'init',buf:startPos?buf:buf,start:startPos||0,vNom});
  },
  setPos(p){ if(this.node) this.node.port.postMessage({t:'pos',p}); },
  setNeedle(d){ if(this.node) this.node.port.postMessage({t:'needle',d}); },
  setSnap(on){ if(this.node) this.node.port.postMessage({t:'snap',on}); }
};

let ybuf=null, T_all=0, nominalStep=0;

/* 根据画面宽度估算“原速咬合”的推进量 */
function calcNominalStep(){
  if(!T_all||!ybuf) return 0;
  const totalSamples = (T_all*HOP + NFFT);
  // 原速：1 秒推进 SR 个样本；我们一次 audio callback 要推进 out.length 个样本，
  // 这里在 Worklet 里按“每输出样本推进多少输入样本”的等比来做。
  // 近似：nominalStep = 1（输出样本）对应 1（输入样本），即可“原速”。
  // 但为了匹配 Griffin–Lim 叠窗导致的轻微时间扩展，略作校正：
  return 1.0;
}

async function prepareAudioFromCanvas(cv){
  const {M,T}=sampleMFromCanvas(cv);
  T_all=T;
  // 快速预览 4 轮
  ybuf = await griffinLimAsync(M,T,4);
  nominalStep = calcNominalStep();
  await audio.start(ybuf, 0, nominalStep);
  // 背景提升音质
  (async()=>{ try{ const y = await griffinLimAsync(M,T,18); ybuf = y; nominalStep = calcNominalStep(); }catch(_){}})();
}

/* ========== 交互：手指=唱针；原速咬合 ========== */
let touching=false, lastX=0,lastT=0;
function screenXToPos(x){
  if(!T_all||!ybuf) return 0;
  const total = (T_all*HOP + NFFT);
  const ratio = Math.max(0, Math.min(1, x / innerWidth));
  return (ratio*(total-1))|0;
}
function onDown(e){
  if(!ybuf) return;
  touching=true;
  audio.ctx && audio.ctx.resume();
  const x = (e.touches? e.touches[0].clientX : e.clientX);
  audio.setPos(screenXToPos(x)); audio.setNeedle(true);
  lastX=x; lastT=performance.now();
}
function onMove(e){
  if(!touching||!ybuf) return;
  const x = (e.touches? e.touches[0].clientX : e.clientX);
  const t = performance.now();
  const dx = x - lastX; const dt = Math.max(1, t - lastT); // ms
  // 计算“屏幕速度”→ 转为是否接近原速
  const pxPerSec = dx / (dt/1000);
  const posPerPx = (T_all*HOP + NFFT) / innerWidth; // 每像素对应多少样本
  const samplesPerSec = pxPerSec * posPerPx;        // 你的滑动产生的“每秒样本推进”
  const near1x = Math.abs(samplesPerSec - SR) < SR*0.12 && dx>0; // 12% 误差内且向右即认定原速
  audio.setSnap(near1x);
  if(!near1x){
    audio.setPos(screenXToPos(x)); // 自由刮盘
  }
  lastX=x; lastT=t;
}
function onUp(){ touching=false; audio.setNeedle(false); audio.setSnap(false); }

document.addEventListener('pointerdown', onDown, {passive:true});
document.addEventListener('pointermove', onMove, {passive:true});
document.addEventListener('pointerup', onUp, {passive:true});
document.addEventListener('touchstart', onDown, {passive:true});
document.addEventListener('touchmove', onMove, {passive:true});
document.addEventListener('touchend', onUp, {passive:true});

/* ========== 启动 ========== */
(async ()=>{
  try{
    await startCam();
    loop();
    // 箭头 5s 后淡出
    setTimeout(()=>icons.classList.add('fadeOut'), 5000);
  }catch(e){
    alert("相机启动失败：请在 HTTPS（如 GitHub Pages）下访问并允许相机权限。");
  }
})();
</script>
</body>
</html>
