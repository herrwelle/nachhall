<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
    <title>Nachhall Êí≠ÊîæÔºàGriffin-Lim ÈáçÂª∫Ôºâ</title>
    <style>
        :root { color-scheme: dark; }
        html, body { margin: 0; height: 100%; background: #000; color: #fff; font-family: system-ui, -apple-system, Segoe UI; }
        #stage { position: fixed; inset: 0; display: grid; place-items: center; }
        video { max-width: 100vw; max-height: 100vh; display: block; opacity: .98; }
        #ui { position: fixed; inset: 0; pointer-events: none; }
        #frame { position: fixed; inset: 0; pointer-events: none; }
        .white { box-shadow: 0 0 0 3px rgba(255,255,255,.6) inset; }
        .green { box-shadow: 0 0 0 4px rgba(0,255,170,.95) inset; }
        #unlock { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,.55); backdrop-filter: blur(2px); cursor: pointer; }
        #unlock button { font-size: 18px; padding: 12px 18px; border-radius: 12px; border: 1px solid #9cf; background: #101b; color: #fff; }
        #log { position: fixed; left: 8px; top: 8px; font: 12px ui-monospace, Menlo, Consolas; color: #9cf; white-space: pre; pointer-events: none; }
    </style>
</head>
<body>
    <div id="stage">
        <video id="cam" playsinline autoplay muted></video>
    </div>
    <canvas id="ui"></canvas>
    <div id="frame" class="white"></div>
    <div id="unlock">
        <button>üîä ÁÇπÂáªËß£ÈîÅÂ£∞Èü≥Âπ∂ÂºÄÂßãÊí≠Êîæ</button>
    </div>
    <div id="log"></div>

    <script>
        /* ==== ÂèÇÊï∞Ôºà‰∏éÁºñÁ†ÅÂô®ÂåπÈÖçÔºâ ==== */
        const CAN_W = 1024, CAN_H = 640;
        const SPEC_X = 0, SPEC_Y = 0, SPEC_W = CAN_W, SPEC_H = CAN_H;
        const SR = 16000, DUR = 3.0, NFFT = 1024, HOP = 128, BINS = NFFT/2 + 1, GL_ITERS = 28;

        /* ==== DOM ÂÖÉÁ¥† ==== */
        const cam = document.getElementById('cam');
        const ui = document.getElementById('ui');
        const frame = document.getElementById('frame');
        const unlock = document.getElementById('unlock');
        const logbox = document.getElementById('log');

        let capCv = null, capCtx = null;
        let actx = null, source = null, buffer = null, startTime = 0, startOffset = 0, playing = false, unlocked = false;
        let frozen = null, building = false;

        function log(s) { logbox.textContent = s; }

        /* ==== Â∑•ÂÖ∑ÂáΩÊï∞ ==== */
        function grayAt(d, i) { return 0.2126 * d[i] + 0.7152 * d[i+1] + 0.0722 * d[i+2]; }

        function findCorners(img, W, H) {
            const data = img.data, th = 90, w3 = W/3|0, h3 = H/3|0;
            
            function best(x0, y0, w, h) {
                let best = {area: 0, cx: 0, cy: 0};
                for (let y = y0; y < y0 + h; y += 2) {
                    for (let x = x0; x < x0 + w; x += 2) {
                        const i = (y * W + x) * 4, g = grayAt(data, i);
                        if (g < th) {
                            let area = 0, sx = 0, sy = 0;
                            for (let yy = y; yy < y + 12 && yy < H; yy += 2) {
                                for (let xx = x; xx < x + 12 && xx < W; xx += 2) {
                                    const ii = (yy * W + xx) * 4;
                                    if (grayAt(data, ii) < th) {
                                        area++; sx += xx; sy += yy;
                                    }
                                }
                            }
                            if (area > best.area) best = {area, cx: sx/area, cy: sy/area};
                        }
                    }
                }
                return best.area ? {x: best.cx, y: best.cy} : null;
            }

            const tl = best(0, 0, w3, h3);
            const tr = best(W - w3, 0, w3, h3);
            const bl = best(0, H - h3, w3, h3);
            const br = best(W - w3, H - h3, w3, h3);
            
            if (tl && tr && bl && br) return [tl, tr, bl, br];
            return null;
        }

        function solveHomography(p) {
            const [tl, tr, bl, br] = p;
            const s = [tl.x, tl.y, tr.x, tr.y, bl.x, bl.y, br.x, br.y];
            const d = [0, 0, CAN_W, 0, 0, CAN_H, CAN_W, CAN_H];
            const [x0,y0,x1,y1,x2,y2,x3,y3] = s;
            const [X0,Y0,X1,Y1,X2,Y2,X3,Y3] = d;

            const M = [
                x0,y0,1, 0,0,0, -X0*x0,-X0*y0,
                0,0,0, x0,y0,1, -Y0*x0,-Y0*y0,
                x1,y1,1, 0,0,0, -X1*x1,-X1*y1,
                0,0,0, x1,y1,1, -Y1*x1,-Y1*y1,
                x2,y2,1, 0,0,0, -X2*x2,-X2*y2,
                0,0,0, x2,y2,1, -Y2*x2,-Y2*y2,
                x3,y3,1, 0,0,0, -X3*x3,-X3*y3,
                0,0,0, x3,y3,1, -Y3*x3,-Y3*y3
            ];
            const B = [X0,Y0,X1,Y1,X2,Y2,X3,Y3];

            const A = new Float64Array(64), bb = new Float64Array(8);
            for (let i = 0; i < 64; i++) A[i] = M[i];
            for (let i = 0; i < 8; i++) bb[i] = B[i];

            // È´òÊñØÊ∂àÂÖÉ
            for (let i = 0; i < 8; i++) {
                let piv = i, pv = Math.abs(A[i*8+i]);
                for (let r = i+1; r < 8; r++) {
                    const v = Math.abs(A[r*8+i]);
                    if (v > pv) { pv = v; piv = r; }
                }
                if (piv !== i) {
                    for (let c = i; c < 8; c++) {
                        [A[i*8+c], A[piv*8+c]] = [A[piv*8+c], A[i*8+c]];
                    }
                    [bb[i], bb[piv]] = [bb[piv], bb[i]];
                }
                const d0 = A[i*8+i];
                for (let c = i; c < 8; c++) A[i*8+c] /= d0;
                bb[i] /= d0;
                for (let r = 0; r < 8; r++) {
                    if (r !== i) {
                        const mul = A[r*8+i];
                        for (let c = i; c < 8; c++) A[r*8+c] -= mul * A[i*8+c];
                        bb[r] -= mul * bb[i];
                    }
                }
            }

            const h = new Float64Array(9);
            for (let i = 0; i < 8; i++) h[i] = bb[i];
            h[8] = 1;
            return h;
        }

        function warpToCanonical(srcImg, W0, H0, Hm) {
            const dst = new ImageData(CAN_W, CAN_H);
            const d = dst.data, s = srcImg.data;
            const a = Hm;
            const A=a[0],B=a[1],C=a[2],D=a[3],E=a[4],F=a[5],G=a[6],H=a[7],I=a[8];
            const det = A*(E*I-F*H) - B*(D*I-F*G) + C*(D*H-E*G);
            const inv = [
                (E*I-F*H)/det, (C*H-B*I)/det, (B*F-C*E)/det,
                (F*G-D*I)/det, (A*I-C*G)/det, (C*D-A*F)/det,
                (D*H-E*G)/det, (B*G-A*H)/det, (A*E-B*D)/det
            ];

            function bilinear(x, y) {
                const x0 = Math.floor(x), y0 = Math.floor(y);
                const x1 = Math.min(W0-1, x0+1), y1 = Math.min(H0-1, y0+1);
                const a = x - x0, b = y - y0;
                const i00 = (y0*W0+x0)*4, i10 = (y0*W0+x1)*4;
                const i01 = (y1*W0+x0)*4, i11 = (y1*W0+x1)*4;
                const r00=s[i00], g00=s[i00+1], b00=s[i00+2];
                const r10=s[i10], g10=s[i10+1], b10=s[i10+2];
                const r01=s[i01], g01=s[i01+1], b01=s[i01+2];
                const r11=s[i11], g11=s[i11+1], b11=s[i11+2];
                const r0 = r00*(1-a) + r10*a, g0 = g00*(1-a) + g10*a, b0 = b00*(1-a) + b10*a;
                const r1 = r01*(1-a) + r11*a, g1 = g01*(1-a) + g11*a, b1 = b01*(1-a) + b11*a;
                return [r0*(1-b) + r1*b, g0*(1-b) + g1*b, b0*(1-b) + b1*b];
            }

            for (let y = 0; y < CAN_H; y++) {
                for (let x = 0; x < CAN_W; x++) {
                    const X = inv[0]*x + inv[1]*y + inv[2];
                    const Y = inv[3]*x + inv[4]*y + inv[5];
                    const Z = inv[6]*x + inv[7]*y + inv[8];
                    const sx = X/Z, sy = Y/Z;
                    const idx = (y*CAN_W + x) * 4;
                    if (sx >= 0 && sx < W0 && sy >= 0 && sy < H0) {
                        const [r, g, b] = bilinear(sx, sy);
                        d[idx] = r; d[idx+1] = g; d[idx+2] = b; d[idx+3] = 255;
                    } else {
                        d[idx] = d[idx+1] = d[idx+2] = 0; d[idx+3] = 255;
                    }
                }
            }
            return dst;
        }

        /* ==== È¢ëË∞±ÊèêÂèñ ==== */
        function extractMagnitudeAuto(img) {
            const data = img.data;
            const frames = Math.floor((SR * DUR - NFFT) / HOP) + 1;
            const mags = new Float32Array(frames * BINS);

            // ÈááÊ†∑ÂØπÊØîÂ∫¶
            const samp = [];
            for (let i = 0; i < 1500; i++) {
                const x = SPEC_X + (Math.random() * SPEC_W) | 0;
                const y = SPEC_Y + (Math.random() * SPEC_H) | 0;
                const idx = (y * CAN_W + x) * 4;
                samp.push(grayAt(data, idx));
            }
            samp.sort((a, b) => a - b);
            const p10 = samp[(samp.length * 0.10) | 0];
            const p90 = samp[(samp.length * 0.90) | 0];
            const den = Math.max(8, p90 - p10);

            // Èªë=Âº∫ÂÅáËÆæ
            const mapBlack = g => Math.max(0, Math.min(1, 1 - (g - p10) / den));

            for (let f = 0; f < frames; f++) {
                const x = SPEC_X + Math.round(f * (SPEC_W - 1) / (frames - 1));
                for (let k = 0; k < BINS; k++) {
                    const y = SPEC_Y + Math.round((SPEC_H - 1) - k * (SPEC_H - 1) / (BINS - 1));
                    const idx = (y * CAN_W + x) * 4;
                    let a = mapBlack(grayAt(data, idx));
                    
                    // È´òÈ¢ëÊäëÂà∂
                    const hf = k / (BINS - 1);
                    a *= (hf < 0.85) ? 1.0 : (1.0 - (hf - 0.85) / 0.15 * 0.25);
                    
                    mags[f * BINS + k] = a;
                }
            }

            // ÂΩí‰∏ÄÂåñ
            const sorted = Array.from(mags).sort((a, b) => a - b);
            const p95 = sorted[(sorted.length * 0.95) | 0] || 1;
            const g = p95 > 1e-6 ? (1.0 / p95) : 1.0;
            for (let i = 0; i < mags.length; i++) mags[i] *= g;

            return { mags, frames };
        }

        /* ==== FFT/IFFT ==== */
        function hann(N) {
            const w = new Float32Array(N);
            for (let n = 0; n < N; n++) w[n] = 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
            return w;
        }

        function fftRadix2(re, im) {
            const N = re.length;
            let j = 0;
            for (let i = 1; i < N - 1; i++) {
                let bit = N >> 1;
                for (; j & bit; bit >>= 1) j ^= bit;
                j ^= bit;
                if (i < j) {
                    [re[i], re[j]] = [re[j], re[i]];
                    [im[i], im[j]] = [im[j], im[i]];
                }
            }
            for (let len = 2; len <= N; len <<= 1) {
                const ang = -2 * Math.PI / len;
                const wlen_r = Math.cos(ang), wlen_i = Math.sin(ang);
                for (let i = 0; i < N; i += len) {
                    let wr = 1, wi = 0;
                    for (let k = 0; k < len / 2; k++) {
                        const u_r = re[i + k], u_i = im[i + k];
                        const v_r = re[i + k + len / 2] * wr - im[i + k + len / 2] * wi;
                        const v_i = re[i + k + len / 2] * wi + im[i + k + len / 2] * wr;
                        re[i + k] = u_r + v_r; im[i + k] = u_i + v_i;
                        re[i + k + len / 2] = u_r - v_r; im[i + k + len / 2] = u_i - v_i;
                        const nwr = wr * wlen_r - wi * wlen_i;
                        const nwi = wr * wlen_i + wi * wlen_r;
                        wr = nwr; wi = nwi;
                    }
                }
            }
        }

        function ifftRadix2(re, im) {
            for (let i = 0; i < re.length; i++) im[i] = -im[i];
            fftRadix2(re, im);
            const N = re.length;
            for (let i = 0; i < N; i++) { re[i] /= N; im[i] /= N; }
        }

        /* ==== Griffin-Lim ==== */
        function griffinLim(mags, frames) {
            const win = hann(NFFT), hop = HOP, bins = BINS;
            const outLen = (frames - 1) * hop + NFFT;

            // ÈöèÊú∫Áõ∏‰ΩçÂàùÂßãÂåñ
            let Sre = new Float32Array(frames * bins);
            let Sim = new Float32Array(frames * bins);
            for (let i = 0; i < Sre.length; i++) {
                const ph = Math.random() * 2 * Math.PI;
                const m = mags[i];
                Sre[i] = m * Math.cos(ph);
                Sim[i] = m * Math.sin(ph);
            }

            function istft(SR, SI) {
                const y = new Float32Array(outLen);
                const wsum = new Float32Array(outLen);
                const fr = new Float32Array(NFFT);
                const fi = new Float32Array(NFFT);

                for (let f = 0; f < frames; f++) {
                    for (let k = 0; k < bins; k++) {
                        fr[k] = SR[f * bins + k];
                        fi[k] = SI[f * bins + k];
                    }
                    for (let k = bins; k < NFFT; k++) {
                        const kk = NFFT - k;
                        fr[k] = fr[kk];
                        fi[k] = -fi[kk];
                    }
                    ifftRadix2(fr, fi);
                    const off = f * hop;
                    for (let n = 0; n < NFFT; n++) {
                        const w = win[n];
                        const v = fr[n] * w;
                        y[off + n] += v;
                        wsum[off + n] += w * w;
                    }
                }
                for (let i = 0; i < outLen; i++) {
                    const d = wsum[i] > 1e-9 ? wsum[i] : 1;
                    y[i] /= d;
                }
                return y;
            }

            function stft(x) {
                const SR2 = new Float32Array(frames * bins);
                const SI2 = new Float32Array(frames * bins);
                const fr = new Float32Array(NFFT);
                const fi = new Float32Array(NFFT);

                for (let f = 0; f < frames; f++) {
                    const off = f * hop;
                    for (let n = 0; n < NFFT; n++) {
                        fr[n] = (x[off + n] || 0) * win[n];
                        fi[n] = 0;
                    }
                    fftRadix2(fr, fi);
                    for (let k = 0; k < bins; k++) {
                        SR2[f * bins + k] = fr[k];
                        SI2[f * bins + k] = fi[k];
                    }
                }
                return { SR2, SI2 };
            }

            // Griffin-Lim Ëø≠‰ª£
            for (let it = 0; it < GL_ITERS; it++) {
                const y = istft(Sre, Sim);
                const { SR2, SI2 } = stft(y);
                for (let i = 0; i < Sre.length; i++) {
                    const r = SR2[i], j = SI2[i];
                    const mag = Math.hypot(r, j);
                    if (mag > 1e-8) {
                        Sre[i] = mags[i] * r / mag;
                        Sim[i] = mags[i] * j / mag;
                    } else {
                        Sre[i] = 0;
                        Sim[i] = 0;
                    }
                }
            }

            // ÊúÄÁªàÈáçÂª∫
            let y = istft(Sre, Sim);

            // ÂéªÁõ¥ÊµÅ + ÂΩí‰∏ÄÂåñ
            let mean = 0;
            for (let i = 0; i < y.length; i++) mean += y[i];
            mean /= y.length;
            for (let i = 0; i < y.length; i++) y[i] -= mean;

            let peak = 1e-9;
            for (let i = 0; i < y.length; i++) peak = Math.max(peak, Math.abs(y[i]));
            const g = 0.98 / peak;
            for (let i = 0; i < y.length; i++) y[i] *= g;

            return y;
        }

        /* ==== Èü≥È¢ëÊí≠Êîæ ==== */
        async function ensureAudio() {
            if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
            if (actx.state !== 'running') {
                try { await actx.resume(); } catch (_) { }
            }
            unlocked = (actx.state === 'running');
            unlock.style.display = unlocked ? 'none' : 'flex';
            return unlocked;
        }

        function playFrom(offsetSec) {
            if (!buffer) return;
            if (source) {
                try { source.stop(); } catch (_) { }
                source.disconnect();
            }
            source = actx.createBufferSource();
            source.buffer = buffer;
            source.connect(actx.destination);
            startTime = actx.currentTime;
            startOffset = Math.max(0, Math.min(buffer.duration, offsetSec || 0));
            source.start(0, startOffset);
            playing = true;
            source.onended = () => { playing = false; };
        }

        function currentU() {
            if (!buffer || !playing) return (startOffset || 0) / (buffer.duration || 1);
            const t = (actx.currentTime - startTime) + startOffset;
            return Math.max(0, Math.min(1, t / (buffer.duration || 1)));
        }

        /* ==== ‰∏ªÂæ™ÁéØ ==== */
        async function loop() {
            capCtx.drawImage(cam, 0, 0, capCv.width, capCv.height);
            const img = capCtx.getImageData(0, 0, capCv.width, capCv.height);

            if (!frozen && !building) {
                const cs = findCorners(img, capCv.width, capCv.height);
                if (cs) {
                    frame.className = 'green';
                    const Hm = solveHomography(cs);
                    frozen = warpToCanonical(img, capCv.width, capCv.height, Hm);
                    building = true;
                    log('Â∑≤ÈîÅÂÆöÔºåÊ≠£Âú®ÊäΩË∞± + Griffin-Lim ÈáçÂª∫‚Ä¶');
                    
                    try {
                        const { mags, frames } = extractMagnitudeAuto(frozen);
                        await ensureAudio();
                        if (!unlocked) {
                            log('‚ö†Ô∏è ÈúÄË¶ÅÁÇπÂáªËß£ÈîÅÂ£∞Èü≥');
                        } else {
                            // Griffin-Lim ÈáçÂª∫
                            const wave = griffinLim(mags, frames);
                            buffer = actx.createBuffer(1, wave.length, SR);
                            buffer.copyToChannel(wave, 0, 0);
                            log(`ÈáçÂª∫ÂÆåÊàêÔºöframes=${frames}, bins=${BINS}\nÁÇπÂáªÂ±èÂπï‰ªªÊÑè‰ΩçÁΩÆÊí≠Êîæ`);
                        }
                    } catch (e) {
                        console.error(e);
                        alert('ÈáçÂª∫Â§±Ë¥•Ôºö' + e.message);
                        frozen = null;
                    } finally {
                        building = false;
                    }
                } else {
                    frame.className = 'white';
                    log('ËØ∑ÊääÂ∏¶ÈªëÊ°ÜÁöÑÈ¢ëË∞±ÁΩÆ‰∫éÂèñÊôØÂô®ÂÜÖÔºàÂá∫Áé∞ÁªøËâ≤ËæπÊ°ÜÂç≥ÈîÅÂÆöÔºâ');
                }
            }

            drawUI();
            requestAnimationFrame(loop);
        }

        /* ==== UI ÁªòÂà∂ ==== */
        function drawUI() {
            ui.width = innerWidth;
            ui.height = innerHeight;
            const ctx = ui.getContext('2d');
            ctx.clearRect(0, 0, ui.width, ui.height);
            
            if (!buffer) return;
            
            const r = cam.getBoundingClientRect();
            const u = currentU();
            const x = Math.round(r.left + u * r.width);
            
            ctx.strokeStyle = 'rgba(255,255,255,.95)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, r.top);
            ctx.lineTo(x, r.bottom);
            ctx.stroke();
        }

        function pointerU(ev) {
            const r = cam.getBoundingClientRect();
            return Math.max(0, Math.min(1, (ev.clientX - r.left) / r.width));
        }

        let dragging = false;

        window.addEventListener('pointerdown', async ev => {
            if (!await ensureAudio()) return;
            if (buffer) {
                dragging = true;
                const u = pointerU(ev);
                playFrom(u * buffer.duration);
            }
        });

        window.addEventListener('pointermove', ev => {
            if (dragging && buffer) {
                const u = pointerU(ev);
                playFrom(u * buffer.duration);
            }
        });

        window.addEventListener('pointerup', () => { dragging = false; });

        unlock.addEventListener('click', async () => {
            await ensureAudio();
            if (buffer) playFrom(currentU() * buffer.duration);
        });

        /* ==== ÂêØÂä®Áõ∏Êú∫ ==== */
        (async () => {
            try {
                const s = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                cam.srcObject = s;
                await cam.play();
                capCv = document.createElement('canvas');
                capCv.width = cam.videoWidth || 1280;
                capCv.height = cam.videoHeight || 720;
                capCtx = capCv.getContext('2d', { willReadFrequently: true });
                log('ËØ∑ÊääÂ∏¶ÈªëÊ°ÜÁöÑÈ¢ëË∞±ÁΩÆ‰∫éÂèñÊôØÂô®ÂÜÖÔºàÂá∫Áé∞ÁªøËâ≤ËæπÊ°ÜÂç≥ÈîÅÂÆöÔºâ');
                requestAnimationFrame(loop);
            } catch (e) {
                alert('Áõ∏Êú∫ÂêØÂä®Â§±Ë¥•ÔºöËØ∑Âú® HTTPS ‰∏ãÂπ∂ÂÖÅËÆ∏Áõ∏Êú∫ÊùÉÈôê');
                log('Áõ∏Êú∫ÂêØÂä®Â§±Ë¥•Ôºö' + e.message);
            }
        })();
    </script>
</body>
</html>
