<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Nachhall · 扫描播放</title>
<style>
  :root{color-scheme:dark}
  html,body{margin:0;height:100%;background:#000;color:#eaffff;font-family:system-ui,-apple-system,Segoe UI}
  #stage{position:fixed;inset:0;display:grid;place-items:center;background:#000}
  video{max-width:100vw;max-height:100vh;display:block;opacity:.98}
  #frame{position:fixed;inset:0;pointer-events:none}
  .white{box-shadow:0 0 0 3px rgba(255,255,255,.65) inset}
  .green{box-shadow:0 0 0 4px rgba(0,255,170,.95) inset}
  .pulse{animation:pulse 1.6s ease-in-out infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 2px rgba(255,255,255,.25) inset}50%{box-shadow:0 0 0 6px rgba(255,255,255,.5) inset}100%{box-shadow:0 0 0 2px rgba(255,255,255,.25) inset}}
  #toast{position:fixed;left:50%;bottom:10%;transform:translateX(-50%);
         padding:10px 14px;border-radius:10px;background:rgba(0,0,0,.6);backdrop-filter:blur(6px);
         font-size:14px;color:#fff;display:none}
</style>
</head>
<body>
<div id="stage"><video id="cam" playsinline autoplay muted></video></div>
<div id="frame" class="white pulse"></div>
<div id="toast">轻触一次以开启声音</div>

<script>
/* === 编码页的固定几何/参数（务必与生成端一致） === */
const SR=16000, NFFT=1024, HOP=512;
const K = NFFT/2 + 1;           // 513 频带
const T = 500;                  // 16 s → 500 帧（16k / 512 = 31.25 fps）
const ENC_MARGIN = 160;         // 编码页使用的内边距（像素）
const CELLX = 3, CELLY = 3;     // 单元尺寸
const DBMIN = -80;              // 灰度映射的 dB 下限
// 整张“标准网格”的理论尺寸（像素）
const GRID_W = 2*ENC_MARGIN + T*CELLX;
const GRID_H = 2*ENC_MARGIN + K*CELLY;

const cam = document.getElementById('cam');
const frame = document.getElementById('frame');
const toast = document.getElementById('toast');

let capCv=null, capCtx=null;
let stableCnt=0, lastRect=null;
let playing=false, lastUsedRect=null;
let actx=null, buffer=null, source=null, durSec=0;

/* —— 相机 —— */
async function startCam(){
  const s = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
  cam.srcObject = s; await cam.play();
  capCv = document.createElement('canvas');
  capCv.width  = cam.videoWidth  || 1280;
  capCv.height = cam.videoHeight || 720;
  capCtx = capCv.getContext('2d',{willReadFrequently:true});
}

/* —— 找黑框（快速投影） —— */
function lumAt(d,i){ return 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; }
function findBlackRect(img,W,H){
  const data=img.data;
  const samples=512, vals=new Float32Array(samples);
  for(let i=0;i<samples;i++){ const x=(i*37)%W, y=(i*61)%H, idx=(y*W+x)*4; vals[i]=lumAt(data,idx); }
  vals.sort(); const thr=Math.max(40, Math.min(140, vals[(samples*0.2)|0]-10));
  const step=2, col=new Float32Array(W), row=new Float32Array(H);
  for(let x=0;x<W;x++){ let dark=0,tot=0; for(let y=0;y<H;y+=step){ const i=(y*W+x)*4; if(lumAt(data,i)<thr) dark++; tot++; } col[x]=dark/Math.max(1,tot); }
  for(let y=0;y<H;y++){ let dark=0,tot=0; for(let x=0;x<W;x+=step){ const i=(y*W+x)*4; if(lumAt(data,i)<thr) dark++; tot++; } row[y]=dark/Math.max(1,tot); }
  function argmax(a,A,B){ let mi=A,mv=-1; for(let i=A;i<=B;i++){ if(a[i]>mv){mv=a[i];mi=i;} } return [mi,mv]; }
  const [xL,sL]=argmax(col,0,(W*0.4)|0);
  const [xR,sR]=argmax(col,(W*0.6)|0,W-1);
  const [yT,sT]=argmax(row,0,(H*0.4)|0);
  const [yB,sB]=argmax(row,(H*0.6)|0,H-1);
  if(sL<0.15||sR<0.15||sT<0.15||sB<0.15) return null;
  const sx=xL, sy=yT, sw=xR-xL+1, sh=yB-yT+1;
  if(sw<120 || sh<120) return null;
  return {sx,sy,sw,sh};
}
function sameRect(a,b){ if(!a||!b) return false;
  return Math.abs(a.sx-b.sx)<8 && Math.abs(a.sy-b.sy)<8 && Math.abs(a.sw-b.sw)<12 && Math.abs(a.sh-b.sh)<12;
}

/* —— 直接在相机帧上按“编码几何”取样（不再用截图/缩放） —— */
function sampleMFromRect(img,W,H,rect){
  const data = img.data;
  const M = new Float32Array(K*T);

  // 从“标准网格坐标”映射到相机像素：线性比例
  const sX = rect.sw / GRID_W;
  const sY = rect.sh / GRID_H;

  for(let t=0;t<T;t++){
    // 标准网格中的列中心
    const gx = ENC_MARGIN + t*CELLX + (CELLX>>1);
    // 映射到相机像素（落在黑框内部）
    const px = rect.sx + sX * gx;

    for(let r=0;r<K;r++){
      const gy = ENC_MARGIN + (K-1-r)*CELLY + (CELLY>>1);
      const py = rect.sy + sY * gy;

      const xi = Math.max(0, Math.min(W-1, px|0));
      const yi = Math.max(0, Math.min(H-1, py|0));
      const idx = (yi*W + xi) * 4;

      const lum = lumAt(data, idx);             // 0(黑)~255(白)
      const norm = Math.max(0, Math.min(1, 1 - lum/255)); // 黑=1（强），白=0
      const db   = DBMIN + norm*(0 - DBMIN);
      const mag  = Math.pow(10, db/20);
      M[t*K + r] = mag;
    }
  }
  return {M};
}

/* —— 迷你 FFT / IFFT + Griffin–Lim —— */
function hann(N){ const w=new Float32Array(N); for(let n=0;n<N;n++) w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); return w; }
const WIN = hann(NFFT);
function makeFFT(N){
  if(N&(N-1)) throw new Error('N must be pow2');
  const cos=new Float32Array(N/2),sin=new Float32Array(N/2);
  for(let i=0;i<N/2;i++){ const a=-2*Math.PI*i/N; cos[i]=Math.cos(a); sin[i]=Math.sin(a); }
  const rev=new Uint32Array(N); let b=0; while((1<<b)<N) b++;
  for(let i=0;i<N;i++){ let x=i,y=0; for(let j=0;j<b;j++){ y=(y<<1)|(x&1); x>>=1; } rev[i]=y; }
  function fft(re,im){
    for(let i=0;i<N;i++){ const j=rev[i]; if(j>i){ let t=re[i]; re[i]=re[j]; re[j]=t; t=im[i]; im[i]=im[j]; im[j]=t; } }
    for(let len=2; len<=N; len<<=1){
      const h=len>>>1, step=N/len;
      for(let i=0;i<N;i+=len) for(let k=0;k<h;k++){
        const c=cos[k*step], s=sin[k*step], j=i+k, l=j+h;
        const r=c*re[l]-s*im[l], ii=s*re[l]+c*im[l];
        re[l]=re[j]-r; im[l]=im[j]-ii; re[j]+=r; im[j]+=ii;
      }
    }
  }
  function ifft(re,im){ for(let i=0;i<N;i++) im[i]=-im[i]; fft(re,im); const inv=1/N; for(let i=0;i<N;i++){ re[i]*=inv; im[i]*=-im[i]; } }
  return {fft,ifft};
}
const FFT = makeFFT(NFFT);

async function griffinLimAsync(M, iter=16){
  const re=new Float32Array(NFFT), im=new Float32Array(NFFT);
  const re2=new Float32Array(NFFT), im2=new Float32Array(NFFT);
  const phase=new Float32Array(K*T); for(let i=0;i<phase.length;i++) phase[i]=Math.random()*2*Math.PI;
  const L=(T-1)*HOP + NFFT; const y=new Float32Array(L);

  for(let it=0; it<iter; it++){
    y.fill(0);
    for(let t=0;t<T;t++){
      for(let k=0;k<K;k++){ const mag=M[t*K+k]; re[k]=mag*Math.cos(phase[t*K+k]); im[k]=mag*Math.sin(phase[t*K+k]); }
      for(let k=K;k<NFFT;k++){ re[k]=0; im[k]=0; }
      for(let k=1;k<K-1;k++){ re[NFFT-k]=re[k]; im[NFFT-k]=-im[k]; }
      FFT.ifft(re,im);
      const off=t*HOP; for(let n=0;n<NFFT;n++) y[off+n]+=re[n]*WIN[n];
    }
    if(it<iter-1){
      for(let t=0;t<T;t++){
        const off=t*HOP; for(let n=0;n<NFFT;n++){ re2[n]=(y[off+n]||0)*WIN[n]; im2[n]=0; }
        FFT.fft(re2,im2); for(let k=0;k<K;k++) phase[t*K+k]=Math.atan2(im2[k],re2[k]);
      }
    }
    await new Promise(r=>setTimeout(r,0)); // 让 UI 呼吸
  }
  // 轻限幅
  let peak=1e-9; for(let i=0;i<y.length;i++) peak=Math.max(peak,Math.abs(y[i]));
  const g=0.9/peak; for(let i=0;i<y.length;i++) y[i]=Math.tanh(y[i]*g);
  return y;
}

/* —— WebAudio 循环播放 —— */
function stopSource(){ try{ source && source.stop(0); }catch(_){} source=null; playing=false; }
async function ensureAudioAllowed(){
  if(!actx) actx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:SR});
  if(actx.state==='suspended'){ try{ await actx.resume(); }catch(_){} }
  return actx.state==='running';
}
function showToast(){ toast.style.display='block'; }
function hideToast(){ toast.style.display='none'; }
function playWave(y){
  stopSource();
  const buf = actx.createBuffer(1, y.length, SR);
  buf.getChannelData(0).set(y);
  buffer=buf; durSec = y.length/SR;
  source = actx.createBufferSource();
  source.buffer = buffer; source.loop = true;
  source.connect(actx.destination); source.start(0);
  playing=true;
}

/* —— 主循环：实时取景；绿=播放，白=暂停 —— */
async function loop(){
  const W=capCv.width, H=capCv.height;
  capCtx.drawImage(cam,0,0,W,H);
  const img = capCtx.getImageData(0,0,W,H);
  const rect = findBlackRect(img,W,H);

  if(rect && sameRect(rect,lastRect)){ stableCnt++; } else { stableCnt=0; }
  lastRect = rect;

  const stable = rect && stableCnt>15; // ~0.5s
  frame.className = stable ? 'green' : 'white pulse';

  if(stable){
    // 若正在播且位置没变，就继续；否则重建一次
    const needRebuild = !playing || !sameRect(rect, lastUsedRect);
    if(needRebuild){
      lastUsedRect = rect;
      if(await ensureAudioAllowed()){
        hideToast();
        const {M} = sampleMFromRect(img,W,H,rect);
        const y = await griffinLimAsync(M, 16); // 16轮够稳
        playWave(y);
      }else{
        showToast();
      }
    }
  }else{
    // 失稳 → 暂停
    if(playing) stopSource();
  }
  requestAnimationFrame(loop);
}

document.addEventListener('pointerdown', async ()=>{
  if(!playing && buffer && await ensureAudioAllowed()){ hideToast();
    stopSource(); const src=actx.createBufferSource(); src.buffer=buffer; src.loop=true; src.connect(actx.destination); src.start(0); source=src; playing=true;}
});

/* 启动 */
(async ()=>{
  try{
    await startCam();
    loop();
  }catch(e){
    alert('相机启动失败：请在 HTTPS（如 GitHub Pages）下访问并允许相机权限。');
  }
})();
</script>
</body>
</html>
