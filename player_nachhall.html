<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
    <title>Nachhall · 扫描播放 (优化版)</title>
    <style>
        :root{color-scheme:dark}
        html,body{margin:0;height:100%;background:#000;color:#eaffff;font-family:system-ui,-apple-system,Segoe UI}
        #stage{position:fixed;inset:0;display:grid;place-items:center;background:#000}
        video{max-width:100vw;max-height:100vh;display:block;opacity:.98}
        #ui{position:fixed;left:0;top:0;width:100vw;height:100vh;pointer-events:none}
        #frame{position:fixed;inset:0;pointer-events:none}
        #info{position:fixed;top:10px;left:10px;font-size:12px;opacity:0.7;pointer-events:none}
        .white{box-shadow:0 0 0 3px rgba(255,255,255,.65) inset}
        .green{box-shadow:0 0 0 4px rgba(0,255,170,.95) inset}
    </style>
</head>
<body>
    <div id="stage">
        <video id="cam" playsinline autoplay muted></video>
    </div>
    <canvas id="ui"></canvas>
    <div id="frame" class="white"></div>
    <div id="info">等待检测频谱图...</div>

    <script>
        /* === 与编码页完全一致的参数 === */
        const SR = 16000, NFFT = 1024, HOP = 512;
        const K = NFFT/2 + 1;           // 513
        const T = 500;                  // 500 帧
        const ENC_MARGIN = 160;         // 版面内边距
        const CELLX = 3, CELLY = 3;
        const DBMIN = -80;              // dB floor
        const GRID_W = 2*ENC_MARGIN + T*CELLX;
        const GRID_H = 2*ENC_MARGIN + K*CELLY;

        const cam = document.getElementById('cam');
        const ui = document.getElementById('ui');
        const frame = document.getElementById('frame');
        const info = document.getElementById('info');

        let capCv = null, capCtx = null;
        let lastRect = null, lastSeenTs = 0;
        let actx = null, buffer = null, source = null, playing = false, durSec = 0;
        let playStart = 0, playOffset = 0;

        /* ========== 相机启动 ========== */
        async function startCam() {
            const s = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' }
            });
            cam.srcObject = s;
            await cam.play();
            
            capCv = document.createElement('canvas');
            capCv.width = cam.videoWidth || 1280;
            capCv.height = cam.videoHeight || 720;
            capCtx = capCv.getContext('2d', { willReadFrequently: true });
        }

        function lumAt(d, i) { 
            return 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]; 
        }

        /* ========== 改进的黑框检测 ========== */
        function findBlackRect(img, W, H) {
            const data = img.data;
            const thr = autoThreshold(data, W, H);
            const step = 2;
            const col = new Float32Array(W), row = new Float32Array(H);

            // 计算每列和每行的暗像素比例
            for(let x = 0; x < W; x++) {
                let dark = 0, tot = 0;
                for(let y = 0; y < H; y += step) {
                    const i = (y*W + x)*4;
                    if(lumAt(data, i) < thr) dark++;
                    tot++;
                }
                col[x] = dark / Math.max(1, tot);
            }

            for(let y = 0; y < H; y++) {
                let dark = 0, tot = 0;
                for(let x = 0; x < W; x += step) {
                    const i = (y*W + x)*4;
                    if(lumAt(data, i) < thr) dark++;
                    tot++;
                }
                row[y] = dark / Math.max(1, tot);
            }

            // 找边界
            const EDGE = 0.15; // 降低阈值，提高检测灵敏度
            let xL = 0; while(xL < W && col[xL] < EDGE) xL++;
            let xR = W-1; while(xR >= 0 && col[xR] < EDGE) xR--;
            let yT = 0; while(yT < H && row[yT] < EDGE) yT++;
            let yB = H-1; while(yB >= 0 && row[yB] < EDGE) yB--;

            if(xR - xL < 100 || yB - yT < 100) return null;

            // 纵横比验证
            const ar = (xR - xL) / (yB - yT);
            if(ar < 0.4 || ar > 4.0) return null;

            return { sx: xL, sy: yT, sw: xR - xL + 1, sh: yB - yT + 1 };
        }

        /* 自适应阈值 */
        function autoThreshold(data, W, H) {
            const N = 800, arr = new Float32Array(N);
            for(let i = 0; i < N; i++) {
                const x = (Math.random() * W) | 0;
                const y = (Math.random() * H) | 0;
                const idx = (y*W + x)*4;
                arr[i] = lumAt(data, idx);
            }
            arr.sort();
            const p = arr[(N * 0.25) | 0]; // 使用25%分位
            return Math.max(25, Math.min(180, p));
        }

        /* ========== 改进的双线性插值采样 ========== */
        function bilinearSample(data, W, H, x, y) {
            const x1 = Math.floor(x), y1 = Math.floor(y);
            const x2 = Math.min(W-1, x1+1), y2 = Math.min(H-1, y1+1);
            const fx = x - x1, fy = y - y1;
            
            const i1 = (y1*W + x1)*4, i2 = (y1*W + x2)*4;
            const i3 = (y2*W + x1)*4, i4 = (y2*W + x2)*4;
            
            const v1 = lumAt(data, i1), v2 = lumAt(data, i2);
            const v3 = lumAt(data, i3), v4 = lumAt(data, i4);
            
            return v1*(1-fx)*(1-fy) + v2*fx*(1-fy) + v3*(1-fx)*fy + v4*fx*fy;
        }

        function percentile(arr, p) {
            const i = Math.max(0, Math.min(arr.length-1, Math.floor(p*(arr.length-1))));
            return arr[i];
        }

        function sampleMFromRect(img, W, H, rect) {
            const data = img.data;
            const M = new Float32Array(K * T);
            
            // 标准网格 → 相机像素 线性映射
            const sX = rect.sw / GRID_W;
            const sY = rect.sh / GRID_H;
            
            // 收集 ROI 亮度用于自适应对比度
            const samp = [];
            for(let i = 0; i < 1000; i++) {
                const gx = ENC_MARGIN + Math.random() * (T * CELLX);
                const gy = ENC_MARGIN + Math.random() * (K * CELLY);
                const px = rect.sx + sX * gx;
                const py = rect.sy + sY * gy;
                
                if(px >= 0 && px < W-1 && py >= 0 && py < H-1) {
                    samp.push(bilinearSample(data, W, H, px, py));
                }
            }
            
            samp.sort((a,b) => a-b);
            const p5 = percentile(samp, 0.05);
            const p95 = percentile(samp, 0.95);
            const denom = Math.max(10, p95 - p5);
            
            // 改进的采样：使用双线性插值 + 5x5平滑
            for(let t = 0; t < T; t++) {
                const gx = ENC_MARGIN + t * CELLX + (CELLX >> 1);
                const px = rect.sx + sX * gx;
                
                for(let r = 0; r < K; r++) {
                    const gy = ENC_MARGIN + (K-1-r) * CELLY + (CELLY >> 1);
                    const py = rect.sy + sY * gy;
                    
                    let acc = 0, cnt = 0;
                    // 5x5 平滑核
                    for(let dy = -2; dy <= 2; dy++) {
                        for(let dx = -2; dx <= 2; dx++) {
                            const x = px + dx;
                            const y = py + dy;
                            if(x >= 0 && x < W-1 && y >= 0 && y < H-1) {
                                acc += bilinearSample(data, W, H, x, y);
                                cnt++;
                            }
                        }
                    }
                    
                    const lum = acc / Math.max(1, cnt);
                    let norm = (p95 - lum) / denom;   // 黑→1，白→0
                    norm = Math.max(0, Math.min(1, norm));
                    
                    // 改进的dB映射，增强动态范围
                    const db = DBMIN + norm * norm * (0 - DBMIN); // 平方增强对比度
                    M[t*K + r] = Math.pow(10, db/20);
                }
            }
            
            return M;
        }

        /* ========== 优化的 FFT/IFFT ========== */
        function hann(N) { 
            const w = new Float32Array(N); 
            for(let n = 0; n < N; n++) 
                w[n] = 0.5 * (1 - Math.cos(2*Math.PI*n/(N-1))); 
            return w; 
        }

        const WIN = hann(NFFT);

        function makeFFT(N) {
            if(N & (N-1)) throw new Error('N must be pow2');
            
            const cos = new Float32Array(N/2), sin = new Float32Array(N/2);
            for(let i = 0; i < N/2; i++) { 
                const a = -2*Math.PI*i/N; 
                cos[i] = Math.cos(a); 
                sin[i] = Math.sin(a); 
            }
            
            const rev = new Uint32Array(N); 
            let b = 0; 
            while((1<<b) < N) b++;
            for(let i = 0; i < N; i++) { 
                let x = i, y = 0; 
                for(let j = 0; j < b; j++) { 
                    y = (y<<1) | (x&1); 
                    x >>= 1; 
                } 
                rev[i] = y; 
            }
            
            function fft(re, im) {
                for(let i = 0; i < N; i++) { 
                    const j = rev[i]; 
                    if(j > i) { 
                        let t = re[i]; re[i] = re[j]; re[j] = t; 
                        t = im[i]; im[i] = im[j]; im[j] = t; 
                    } 
                }
                
                for(let len = 2; len <= N; len <<= 1) { 
                    const h = len >>> 1, step = N/len;
                    for(let i = 0; i < N; i += len) {
                        for(let k = 0; k < h; k++) {
                            const c = cos[k*step], s = sin[k*step];
                            const j = i+k, l = j+h;
                            const r = c*re[l] - s*im[l];
                            const ii = s*re[l] + c*im[l];
                            re[l] = re[j] - r; 
                            im[l] = im[j] - ii; 
                            re[j] += r; 
                            im[j] += ii;
                        }
                    }
                }
            }
            
            function ifft(re, im) { 
                for(let i = 0; i < N; i++) im[i] = -im[i]; 
                fft(re, im); 
                const inv = 1/N; 
                for(let i = 0; i < N; i++) { 
                    re[i] *= inv; 
                    im[i] *= -inv; 
                } 
            }
            
            return { fft, ifft };
        }

        const FFT = makeFFT(NFFT);      
  /* ========== 大幅优化的 Griffin-Lim 算法 ========== */
        async function griffinLim(M, iters = 60) {
            const re = new Float32Array(NFFT), im = new Float32Array(NFFT);
            const re2 = new Float32Array(NFFT), im2 = new Float32Array(NFFT);
            
            // 智能初始相位：使用随机相位但保持频率连续性
            const phase = new Float32Array(K * T);
            for(let t = 0; t < T; t++) {
                for(let k = 0; k < K; k++) {
                    if(t === 0) {
                        phase[t*K + k] = Math.random() * 2 * Math.PI;
                    } else {
                        // 相位连续性：基于前一帧 + 小随机扰动
                        const prevPhase = phase[(t-1)*K + k];
                        phase[t*K + k] = prevPhase + (Math.random() - 0.5) * 0.5;
                    }
                }
            }
            
            // 预计算 OLA 归一权重
            const L = (T-1) * HOP + NFFT;
            const y = new Float32Array(L);
            const wsum = new Float32Array(L);
            
            for(let t = 0; t < T; t++) {
                const off = t * HOP;
                for(let n = 0; n < NFFT; n++) { 
                    wsum[off + n] += WIN[n] * WIN[n]; 
                }
            }
            
            // 迭代重建
            for(let it = 0; it < iters; it++) {
                y.fill(0);
                
                // ISTFT: 频域 → 时域
                for(let t = 0; t < T; t++) {
                    // 构建复数频谱
                    for(let k = 0; k < K; k++) { 
                        const mag = M[t*K + k]; 
                        re[k] = mag * Math.cos(phase[t*K + k]); 
                        im[k] = mag * Math.sin(phase[t*K + k]); 
                    }
                    
                    // 镜像对称（实信号）
                    for(let k = K; k < NFFT; k++) { 
                        re[k] = 0; 
                        im[k] = 0; 
                    }
                    for(let k = 1; k < K-1; k++) { 
                        re[NFFT-k] = re[k]; 
                        im[NFFT-k] = -im[k]; 
                    }
                    
                    FFT.ifft(re, im);
                    
                    const off = t * HOP;
                    for(let n = 0; n < NFFT; n++) { 
                        y[off + n] += re[n] * WIN[n]; 
                    }
                }
                
                // OLA 归一化
                for(let i = 0; i < L; i++) { 
                    if(wsum[i] > 1e-9) y[i] /= wsum[i]; 
                }
                
                if(it < iters - 1) {
                    // STFT: 时域 → 频域，更新相位
                    for(let t = 0; t < T; t++) {
                        const off = t * HOP;
                        for(let n = 0; n < NFFT; n++) { 
                            re2[n] = (y[off + n] || 0) * WIN[n]; 
                            im2[n] = 0; 
                        }
                        
                        FFT.fft(re2, im2);
                        
                        // 强制幅度一致性 + 相位平滑
                        for(let k = 0; k < K; k++) {
                            const mag = Math.sqrt(re2[k]*re2[k] + im2[k]*im2[k]);
                            if(mag > 1e-10) {
                                const targetMag = M[t*K + k];
                                // 强制匹配目标幅度
                                re2[k] = re2[k] * targetMag / mag;
                                im2[k] = im2[k] * targetMag / mag;
                            }
                            
                            let newPhase = Math.atan2(im2[k], re2[k]);
                            
                            // 相位平滑：与相邻帧的相位保持连续性
                            if(t > 0 && k > 0) {
                                const prevPhase = phase[(t-1)*K + k];
                                const diff = newPhase - prevPhase;
                                // 处理相位跳跃
                                if(diff > Math.PI) newPhase -= 2*Math.PI;
                                else if(diff < -Math.PI) newPhase += 2*Math.PI;
                                
                                // 轻微平滑
                                newPhase = 0.8 * newPhase + 0.2 * prevPhase;
                            }
                            
                            phase[t*K + k] = newPhase;
                        }
                    }
                }
                
                // 每10次迭代给个进度提示
                if(it % 10 === 0) {
                    info.textContent = `重建音频中... ${Math.round(it/iters*100)}%`;
                    await new Promise(r => setTimeout(r, 1));
                }
            }
            
            // 改进的后处理
            let peak = 1e-9; 
            for(let i = 0; i < y.length; i++) 
                peak = Math.max(peak, Math.abs(y[i]));
            
            // 动态范围压缩 + 轻微限幅
            const g = 0.8 / peak; 
            for(let i = 0; i < y.length; i++) {
                y[i] *= g;
                // 软限幅，保持音质
                y[i] = Math.tanh(y[i] * 1.2) * 0.9;
            }
            
            // 简单的高频增强（提升清晰度）
            for(let i = 1; i < y.length - 1; i++) {
                const highFreq = (y[i-1] - 2*y[i] + y[i+1]) * 0.1;
                y[i] += highFreq;
            }
            
            info.textContent = '音频重建完成';
            return y;
        }

        /* ========== 播放控制（修复循环问题） ========== */
        function stopSource() { 
            try { 
                source && source.stop(0); 
            } catch(_) {} 
            source = null; 
            playing = false; 
        }

        async function ensureAudio() {
            if(!actx) {
                actx = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SR
                });
            }
            if(actx.state === 'suspended') { 
                try { 
                    await actx.resume(); 
                } catch(_) {} 
            }
            return actx.state === 'running';
        }

        function playBuffer(y) {
            stopSource();
            
            const buf = actx.createBuffer(1, y.length, SR);
            buf.getChannelData(0).set(y);
            buffer = buf; 
            durSec = y.length / SR;
            
            source = actx.createBufferSource();
            source.buffer = buffer; 
            source.loop = true;
            source.connect(actx.destination);
            
            playOffset = 0;
            playStart = actx.currentTime;
            source.start(0);
            playing = true;
            
            info.textContent = `播放中 (${durSec.toFixed(1)}s)`;
        }

        /* ========== 主循环：检测和播放 ========== */
        let debounceRebuild = 0;
        
        async function loop() {
            const W = capCv.width, H = capCv.height;
            capCtx.drawImage(cam, 0, 0, W, H);
            const img = capCtx.getImageData(0, 0, W, H);
            const rect = findBlackRect(img, W, H);
            const now = performance.now();
            const hasRect = !!rect;
            
            if(hasRect) { 
                lastSeenTs = now; 
                frame.className = 'green'; 
            } else { 
                frame.className = 'white'; 
            }
            
            // 检测到框就尝试播放
            if(hasRect) {
                const moved = !lastRect || 
                    Math.abs(rect.sx - lastRect.sx) > 8 || 
                    Math.abs(rect.sy - lastRect.sy) > 8 || 
                    Math.abs(rect.sw - lastRect.sw) > 12 || 
                    Math.abs(rect.sh - lastRect.sh) > 12;
                
                lastRect = rect;
                
                if(moved || (now - debounceRebuild > 2000) || !playing) {
                    debounceRebuild = now;
                    if(await ensureAudio()) {
                        info.textContent = '检测到频谱图，开始采样...';
                        const M = sampleMFromRect(img, W, H, rect);
                        const y = await griffinLim(M, 60);  // 60次迭代
                        playBuffer(y);
                    }
                }
            } else {
                // 离开画面 0.8s 后暂停
                if(playing && now - lastSeenTs > 800) { 
                    stopSource(); 
                    info.textContent = '频谱图丢失，播放暂停';
                }
            }
            
            drawUIOverlay(rect);
            requestAnimationFrame(loop);
        }

        /* ========== 修复的 UI 叠加层：正确的循环播放头 ========== */
        function drawUIOverlay(rect) {
            const ctx = ui.getContext('2d');
            const W = ui.width = innerWidth;
            const H = ui.height = innerHeight;
            ctx.clearRect(0, 0, W, H);
            
            if(!playing || !buffer || !rect) return;
            
            // 修复的时间计算：确保循环
            const now = actx.currentTime;
            const elapsed = (now - playStart + playOffset) % durSec;
            const progress = elapsed / durSec;  // 0 到 1
            const col = Math.floor(progress * T) % T;  // 确保在 0 到 T-1 之间循环
            
            // rect 在相机像素；转换到屏幕像素
            const vRect = cam.getBoundingClientRect();
            const sx = vRect.width / capCv.width;
            const sy = vRect.height / capCv.height;
            const ox = vRect.left, oy = vRect.top;
            
            // 标准网格列中心 → 相机像素
            const sX = rect.sw / GRID_W;
            const gx = ENC_MARGIN + col * CELLX + (CELLX >> 1);
            const px = rect.sx + sX * gx;
            
            // 相机像素 → 屏幕像素
            const screenX = Math.round(ox + px * sx);
            
            // 绘制播放头
            ctx.strokeStyle = 'rgba(255,255,255,.95)';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 2;
            
            ctx.beginPath();
            ctx.moveTo(screenX, oy);
            ctx.lineTo(screenX, oy + vRect.height);
            ctx.stroke();
            
            // 重置阴影
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // 在播放头顶部显示进度
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`${(progress*100).toFixed(0)}%`, screenX, oy + 15);
        }

        /* ========== 启动 ========== */
        (async () => {
            try {
                info.textContent = '启动相机中...';
                await startCam();
                info.textContent = '相机就绪，请对准频谱图';
                loop();
            } catch(e) {
                info.textContent = '相机启动失败：请在 HTTPS 下访问并允许相机权限';
                console.error(e);
            }
        })();
    </script>
</body>
</html>