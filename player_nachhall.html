<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
    <title>Nachhall · 调试版</title>
    <style>
        :root{color-scheme:dark}
        html,body{margin:0;height:100%;background:#000;color:#eaffff;font-family:system-ui,-apple-system,Segoe UI}
        #stage{position:fixed;inset:0;display:grid;place-items:center;background:#000}
        video{max-width:100vw;max-height:100vh;display:block;opacity:.98}
        #ui{position:fixed;left:0;top:0;width:100vw;height:100vh;pointer-events:none}
        #frame{position:fixed;inset:0;pointer-events:none}
        #info{position:fixed;top:10px;left:10px;font-size:11px;opacity:0.9;pointer-events:none;background:rgba(0,0,0,0.7);padding:8px;border-radius:4px;max-width:300px;line-height:1.3}
        #debug{position:fixed;bottom:10px;left:10px;font-size:10px;opacity:0.8;pointer-events:none;background:rgba(0,0,0,0.7);padding:5px;border-radius:3px;font-family:monospace}
        .white{box-shadow:0 0 0 3px rgba(255,255,255,.65) inset}
        .green{box-shadow:0 0 0 4px rgba(0,255,170,.95) inset}
    </style>
</head>
<body>
    <div id="stage">
        <video id="cam" playsinline autoplay muted></video>
    </div>
    <canvas id="ui"></canvas>
    <div id="frame" class="white"></div>
    <div id="info">等待检测频谱图...</div>
    <div id="debug">调试信息</div>

    <script>
        /* === 参数设置 === */
        const SR = 16000, NFFT = 1024, HOP = 512;
        const K = NFFT/2 + 1;
        const T = 500;
        const ENC_MARGIN = 160;
        const CELLX = 3, CELLY = 3;
        const DBMIN = -80;
        const GRID_W = 2*ENC_MARGIN + T*CELLX;
        const GRID_H = 2*ENC_MARGIN + K*CELLY;

        const cam = document.getElementById('cam');
        const ui = document.getElementById('ui');
        const frame = document.getElementById('frame');
        const info = document.getElementById('info');
        const debug = document.getElementById('debug');

        let capCv = null, capCtx = null;
        let lastRect = null, lastSeenTs = 0;
        let actx = null, buffer = null, source = null, playing = false, durSec = 0;
        let playStart = 0;
        let frameCount = 0;

        function updateDebug(msg) {
            debug.textContent = msg;
            console.log(msg);
        }

        /* ========== 相机启动 ========== */
        async function startCam() {
            const s = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment' }
            });
            cam.srcObject = s;
            await cam.play();
            
            capCv = document.createElement('canvas');
            capCv.width = cam.videoWidth || 1280;
            capCv.height = cam.videoHeight || 720;
            capCtx = capCv.getContext('2d', { willReadFrequently: true });
            updateDebug(`相机: ${capCv.width}x${capCv.height}`);
        }

        function lumAt(d, i) { 
            return 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2]; 
        }

        /* ========== 简化的黑框检测 ========== */
        function findBlackRect(img, W, H) {
            const data = img.data;
            
            // 简单阈值
            const threshold = 100;
            
            // 从四边扫描找边界
            let left = 0, right = W-1, top = 0, bottom = H-1;
            
            // 找左边界
            for(let x = 0; x < W; x++) {
                let darkCount = 0;
                for(let y = 0; y < H; y += 5) {
                    if(lumAt(data, (y*W + x)*4) < threshold) darkCount++;
                }
                if(darkCount > H/10) { left = x; break; }
            }
            
            // 找右边界
            for(let x = W-1; x >= 0; x--) {
                let darkCount = 0;
                for(let y = 0; y < H; y += 5) {
                    if(lumAt(data, (y*W + x)*4) < threshold) darkCount++;
                }
                if(darkCount > H/10) { right = x; break; }
            }
            
            // 找上边界
            for(let y = 0; y < H; y++) {
                let darkCount = 0;
                for(let x = 0; x < W; x += 5) {
                    if(lumAt(data, (y*W + x)*4) < threshold) darkCount++;
                }
                if(darkCount > W/10) { top = y; break; }
            }
            
            // 找下边界
            for(let y = H-1; y >= 0; y--) {
                let darkCount = 0;
                for(let x = 0; x < W; x += 5) {
                    if(lumAt(data, (y*W + x)*4) < threshold) darkCount++;
                }
                if(darkCount > W/10) { bottom = y; break; }
            }
            
            const w = right - left;
            const h = bottom - top;
            
            if(w < 100 || h < 100) return null;
            
            return { sx: left, sy: top, sw: w, sh: h };
        }

        /* ========== 简化采样 ========== */
        function sampleMFromRect(img, W, H, rect) {
            const data = img.data;
            const M = new Float32Array(K * T);
            
            const sX = rect.sw / GRID_W;
            const sY = rect.sh / GRID_H;
            
            for(let t = 0; t < T; t++) {
                const gx = ENC_MARGIN + t * CELLX + 1;
                const px = rect.sx + sX * gx;
                
                for(let r = 0; r < K; r++) {
                    const gy = ENC_MARGIN + (K-1-r) * CELLY + 1;
                    const py = rect.sy + sY * gy;
                    
                    const xi = Math.max(0, Math.min(W-1, Math.round(px)));
                    const yi = Math.max(0, Math.min(H-1, Math.round(py)));
                    const idx = (yi*W + xi)*4;
                    const lum = lumAt(data, idx);
                    
                    // 简单映射：亮度越低，幅度越高
                    const norm = Math.max(0, Math.min(1, (255 - lum) / 200));
                    const db = DBMIN + norm * (0 - DBMIN);
                    M[t*K + r] = Math.pow(10, db/20);
                }
            }
            
            return M;
        }

        /* ========== 简化FFT ========== */
        function hann(N) { 
            const w = new Float32Array(N); 
            for(let n = 0; n < N; n++) 
                w[n] = 0.5 * (1 - Math.cos(2*Math.PI*n/(N-1))); 
            return w; 
        }

        const WIN = hann(NFFT);

        function makeFFT(N) {
            if(N & (N-1)) throw new Error('N must be pow2');
            
            const cos = new Float32Array(N/2), sin = new Float32Array(N/2);
            for(let i = 0; i < N/2; i++) { 
                const a = -2*Math.PI*i/N; 
                cos[i] = Math.cos(a); 
                sin[i] = Math.sin(a); 
            }
            
            const rev = new Uint32Array(N); 
            let b = 0; 
            while((1<<b) < N) b++;
            for(let i = 0; i < N; i++) { 
                let x = i, y = 0; 
                for(let j = 0; j < b; j++) { 
                    y = (y<<1) | (x&1); 
                    x >>= 1; 
                } 
                rev[i] = y; 
            }
            
            function fft(re, im) {
                for(let i = 0; i < N; i++) { 
                    const j = rev[i]; 
                    if(j > i) { 
                        let t = re[i]; re[i] = re[j]; re[j] = t; 
                        t = im[i]; im[i] = im[j]; im[j] = t; 
                    } 
                }
                
                for(let len = 2; len <= N; len <<= 1) { 
                    const h = len >>> 1, step = N/len;
                    for(let i = 0; i < N; i += len) {
                        for(let k = 0; k < h; k++) {
                            const c = cos[k*step], s = sin[k*step];
                            const j = i+k, l = j+h;
                            const r = c*re[l] - s*im[l];
                            const ii = s*re[l] + c*im[l];
                            re[l] = re[j] - r; 
                            im[l] = im[j] - ii; 
                            re[j] += r; 
                            im[j] += ii;
                        }
                    }
                }
            }
            
            function ifft(re, im) { 
                for(let i = 0; i < N; i++) im[i] = -im[i]; 
                fft(re, im); 
                const inv = 1/N; 
                for(let i = 0; i < N; i++) { 
                    re[i] *= inv; 
                    im[i] *= -inv; 
                } 
            }
            
            return { fft, ifft };
        }

        const FFT = makeFFT(NFFT);    
    /* ========== 极简Griffin-Lim ========== */
        async function griffinLim(M, iters = 15) {
            updateDebug(`开始Griffin-Lim: ${iters}次迭代`);
            
            const re = new Float32Array(NFFT), im = new Float32Array(NFFT);
            const re2 = new Float32Array(NFFT), im2 = new Float32Array(NFFT);
            
            // 随机相位
            const phase = new Float32Array(K * T);
            for(let i = 0; i < phase.length; i++) {
                phase[i] = Math.random() * 2 * Math.PI;
            }
            
            const L = (T-1) * HOP + NFFT;
            const y = new Float32Array(L);
            const wsum = new Float32Array(L);
            
            for(let t = 0; t < T; t++) {
                const off = t * HOP;
                for(let n = 0; n < NFFT; n++) { 
                    wsum[off + n] += WIN[n] * WIN[n]; 
                }
            }
            
            for(let it = 0; it < iters; it++) {
                y.fill(0);
                
                for(let t = 0; t < T; t++) {
                    for(let k = 0; k < K; k++) { 
                        const mag = M[t*K + k]; 
                        re[k] = mag * Math.cos(phase[t*K + k]); 
                        im[k] = mag * Math.sin(phase[t*K + k]); 
                    }
                    
                    for(let k = K; k < NFFT; k++) { 
                        re[k] = 0; 
                        im[k] = 0; 
                    }
                    for(let k = 1; k < K-1; k++) { 
                        re[NFFT-k] = re[k]; 
                        im[NFFT-k] = -im[k]; 
                    }
                    
                    FFT.ifft(re, im);
                    
                    const off = t * HOP;
                    for(let n = 0; n < NFFT; n++) { 
                        y[off + n] += re[n] * WIN[n]; 
                    }
                }
                
                for(let i = 0; i < L; i++) { 
                    if(wsum[i] > 1e-9) y[i] /= wsum[i]; 
                }
                
                if(it < iters - 1) {
                    for(let t = 0; t < T; t++) {
                        const off = t * HOP;
                        for(let n = 0; n < NFFT; n++) { 
                            re2[n] = (y[off + n] || 0) * WIN[n]; 
                            im2[n] = 0; 
                        }
                        
                        FFT.fft(re2, im2);
                        
                        for(let k = 0; k < K; k++) {
                            phase[t*K + k] = Math.atan2(im2[k], re2[k]);
                        }
                    }
                }
                
                if(it % 3 === 0) {
                    const progress = Math.round(it/iters*100);
                    info.textContent = `重建音频中... ${progress}%`;
                    updateDebug(`Griffin-Lim: ${progress}%`);
                    await new Promise(r => setTimeout(r, 1));
                }
            }
            
            // 归一化
            let peak = 1e-9; 
            for(let i = 0; i < y.length; i++) 
                peak = Math.max(peak, Math.abs(y[i]));
            
            if(peak > 0) {
                const g = 0.5 / peak; 
                for(let i = 0; i < y.length; i++) {
                    y[i] *= g;
                }
            }
            
            updateDebug(`Griffin-Lim完成: ${y.length}样本`);
            return y;
        }

        /* ========== 音频播放 ========== */
        function stopSource() { 
            if(source) {
                try {
                    source.stop();
                    source.disconnect();
                } catch(e) {}
                source = null;
            }
            playing = false; 
            updateDebug('音频停止');
        }

        async function ensureAudio() {
            if(!actx) {
                actx = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SR
                });
                updateDebug(`音频上下文创建: ${actx.sampleRate}Hz`);
            }
            
            if(actx.state === 'suspended') { 
                await actx.resume(); 
                updateDebug(`音频上下文恢复: ${actx.state}`);
            }
            
            return actx.state === 'running';
        }

        function playBuffer(y) {
            updateDebug(`准备播放: ${y.length}样本`);
            stopSource();
            
            const buf = actx.createBuffer(1, y.length, SR);
            buf.getChannelData(0).set(y);
            buffer = buf; 
            durSec = y.length / SR;
            
            source = actx.createBufferSource();
            source.buffer = buffer; 
            source.loop = true;
            source.connect(actx.destination);
            
            // 重要：记录真实的开始时间
            playStart = actx.currentTime;
            source.start(0);
            playing = true;
            
            updateDebug(`播放开始: ${durSec.toFixed(2)}s, 开始时间: ${playStart.toFixed(3)}`);
            info.textContent = `播放中 (${durSec.toFixed(1)}s)`;
            
            // 测试播放头计算
            setTimeout(() => {
                if(playing && actx) {
                    const now = actx.currentTime;
                    const elapsed = now - playStart;
                    updateDebug(`测试: 当前${now.toFixed(3)}, 经过${elapsed.toFixed(3)}s`);
                }
            }, 1000);
        }

        /* ========== 主循环 ========== */
        let debounceRebuild = 0;
        
        async function loop() {
            frameCount++;
            const W = capCv.width, H = capCv.height;
            capCtx.drawImage(cam, 0, 0, W, H);
            const img = capCtx.getImageData(0, 0, W, H);
            const rect = findBlackRect(img, W, H);
            const now = performance.now();
            const hasRect = !!rect;
            
            if(hasRect) { 
                lastSeenTs = now; 
                frame.className = 'green'; 
            } else { 
                frame.className = 'white'; 
            }
            
            if(hasRect) {
                const moved = !lastRect || 
                    Math.abs(rect.sx - lastRect.sx) > 15 || 
                    Math.abs(rect.sy - lastRect.sy) > 15 || 
                    Math.abs(rect.sw - lastRect.sw) > 20 || 
                    Math.abs(rect.sh - lastRect.sh) > 20;
                
                lastRect = rect;
                
                if(moved || (now - debounceRebuild > 4000) || !playing) {
                    debounceRebuild = now;
                    if(await ensureAudio()) {
                        updateDebug(`检测到频谱: ${rect.sw}x${rect.sh} at (${rect.sx},${rect.sy})`);
                        info.textContent = '检测到频谱图，开始采样...';
                        
                        try {
                            const M = sampleMFromRect(img, W, H, rect);
                            const y = await griffinLim(M, 15);
                            playBuffer(y);
                        } catch(e) {
                            updateDebug(`错误: ${e.message}`);
                            info.textContent = '音频重建失败';
                        }
                    }
                }
            } else {
                if(playing && now - lastSeenTs > 1500) { 
                    stopSource(); 
                    info.textContent = '频谱图丢失，播放暂停';
                }
            }
            
            // 每秒更新一次帧率
            if(frameCount % 30 === 0) {
                updateDebug(`帧率: ~30fps, 播放: ${playing}`);
            }
            
            drawUIOverlay(rect);
            requestAnimationFrame(loop);
        }

        /* ========== 播放头显示（重点修复） ========== */
        function drawUIOverlay(rect) {
            const ctx = ui.getContext('2d');
            const W = ui.width = innerWidth;
            const H = ui.height = innerHeight;
            ctx.clearRect(0, 0, W, H);
            
            if(!playing || !buffer || !rect || !actx) return;
            
            try {
                // 关键修复：确保时间计算正确
                const now = actx.currentTime;
                const elapsed = now - playStart;
                
                // 防止负数和异常值
                if(elapsed < 0 || !isFinite(elapsed) || durSec <= 0) {
                    updateDebug(`时间异常: now=${now}, start=${playStart}, dur=${durSec}`);
                    return;
                }
                
                // 循环进度计算
                const progress = (elapsed % durSec) / durSec;
                const col = Math.floor(progress * T);
                
                // 确保col在有效范围内
                const safeCol = Math.max(0, Math.min(T-1, col));
                
                // 坐标转换
                const vRect = cam.getBoundingClientRect();
                const sx = vRect.width / capCv.width;
                const ox = vRect.left, oy = vRect.top;
                
                const sX = rect.sw / GRID_W;
                const gx = ENC_MARGIN + safeCol * CELLX + (CELLX >> 1);
                const px = rect.sx + sX * gx;
                const screenX = Math.round(ox + px * sx);
                
                // 绘制播放头
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(screenX, oy);
                ctx.lineTo(screenX, oy + vRect.height);
                ctx.stroke();
                
                // 显示详细信息
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${(progress*100).toFixed(0)}%`, screenX, oy + 12);
                ctx.fillText(`${safeCol}/${T}`, screenX, oy + 24);
                
                // 每秒更新一次调试信息
                if(frameCount % 30 === 0) {
                    updateDebug(`播放头: col=${safeCol}, progress=${(progress*100).toFixed(1)}%, elapsed=${elapsed.toFixed(2)}s`);
                }
                
            } catch(e) {
                updateDebug(`绘制错误: ${e.message}`);
            }
        }

        /* ========== 启动 ========== */
        (async () => {
            try {
                info.textContent = '启动相机中...';
                updateDebug('开始启动...');
                await startCam();
                info.textContent = '相机就绪，请对准频谱图';
                updateDebug('相机就绪，开始主循环');
                loop();
            } catch(e) {
                info.textContent = '相机启动失败：请在 HTTPS 下访问并允许相机权限';
                updateDebug(`启动失败: ${e.message}`);
            }
        })();
    </script>
</body>
</html>