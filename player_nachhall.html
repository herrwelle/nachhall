<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Nachhall · 扫描播放</title>
<style>
  :root{color-scheme:dark}
  html,body{margin:0;height:100%;background:#000;color:#eaffff;font-family:system-ui,-apple-system,Segoe UI}
  #stage{position:fixed;inset:0;display:grid;place-items:center;background:#000}
  video{max-width:100vw;max-height:100vh;opacity:.95}
  canvas{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);image-rendering:pixelated;display:none}
  #frame{position:fixed;inset:0;pointer-events:none}
  .white{box-shadow:0 0 0 3px rgba(255,255,255,.65) inset}
  .green{box-shadow:0 0 0 4px rgba(0,255,170,.9) inset}
  .pulse{animation:pulse 1.6s ease-in-out infinite}
  @keyframes pulse{0%{box-shadow:0 0 0 2px rgba(255,255,255,.25) inset}50%{box-shadow:0 0 0 6px rgba(255,255,255,.55) inset}100%{box-shadow:0 0 0 2px rgba(255,255,255,.25) inset}}
  #toast{position:fixed;left:50%;bottom:10%;transform:translateX(-50%);padding:10px 14px;border-radius:10px;background:rgba(0,0,0,.6);backdrop-filter:blur(6px);
         font-size:14px;color:#fff;display:none}
</style>
</head>
<body>
<div id="stage">
  <video id="cam" playsinline autoplay muted></video>
  <!-- 锁定后显示的谱图（静态底图） -->
  <canvas id="spec"></canvas>
  <!-- 播放指示线覆盖层 -->
  <canvas id="ui"></canvas>
</div>
<div id="frame" class="white pulse"></div>
<div id="toast">轻触一次以开启声音</div>

<script>
/* 固定参数（与编码页一致） */
const SR=16000,NFFT=1024,HOP=512,K=NFFT/2+1,CELLX=3,CELLY=3,MARGIN=20,DBMIN=-80;

/* DOM */
const cam=document.getElementById('cam');
const spec=document.getElementById('spec');
const ui=document.getElementById('ui');
const frame=document.getElementById('frame');
const toast=document.getElementById('toast');

/* 相机/锁定 */
let capCv=null, capCtx=null;
let stableCnt=0,lastRect=null, locked=false;

async function startCam(){
  const s = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
  cam.srcObject=s; await cam.play();
  capCv=document.createElement('canvas');
  capCv.width=cam.videoWidth||1280; capCv.height=cam.videoHeight||720;
  capCtx=capCv.getContext('2d',{willReadFrequently:true});
}

function lumAt(d,i){ return 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; }
function findBlackRect(img,W,H){
  const data=img.data;
  const samples=512, vals=new Float32Array(samples);
  for(let i=0;i<samples;i++){ const x=(i*37)%W,y=(i*61)%H,idx=(y*W+x)*4; vals[i]=lumAt(data,idx); }
  vals.sort(); const thr=Math.max(40,Math.min(140,vals[(samples*0.2)|0]-10));
  const step=2, col=new Float32Array(W), row=new Float32Array(H);
  for(let x=0;x<W;x++){ let dark=0,tot=0; for(let y=0;y<H;y+=step){ const i=(y*W+x)*4; if(lumAt(data,i)<thr) dark++; tot++; } col[x]=dark/Math.max(1,tot); }
  for(let y=0;y<H;y++){ let dark=0,tot=0; for(let x=0;x<W;x+=step){ const i=(y*W+x)*4; if(lumAt(data,i)<thr) dark++; tot++; } row[y]=dark/Math.max(1,tot); }
  function argmax(a,A,B){ let mi=A,mv=-1; for(let i=A;i<=B;i++){ if(a[i]>mv){mv=a[i];mi=i;} } return [mi,mv]; }
  const [xL,sL]=argmax(col,0,(W*0.4)|0);
  const [xR,sR]=argmax(col,(W*0.6)|0,W-1);
  const [yT,sT]=argmax(row,0,(H*0.4)|0);
  const [yB,sB]=argmax(row,(H*0.6)|0,H-1);
  if(sL<0.15||sR<0.15||sT<0.15||sB<0.15) return null;
  const sx=xL, sy=yT, sw=xR-xL+1, sh=yB-yT+1;
  if(sw<80||sh<80) return null;
  return {sx,sy,sw,sh};
}
function sameRect(a,b){ if(!a||!b) return false; const dx=Math.abs(a.sx-b.sx),dy=Math.abs(a.sy-b.sy),dw=Math.abs(a.sw-b.sw),dh=Math.abs(a.sh-b.sh); return dx<8&&dy<8&&dw<12&&dh<12; }

/* 抓图并“平铺”为标准网格（静态谱图） */
function grabSpectroCanvas(rect){
  const T = Math.round((rect.sw - 2*MARGIN)/CELLX);
  const gridW = 2*MARGIN + T*CELLX;
  const gridH = 2*MARGIN + K*CELLY;

  spec.width=gridW; spec.height=gridH;
  const sctx=spec.getContext('2d'); sctx.imageSmoothingEnabled=false;
  sctx.drawImage(capCv, rect.sx,rect.sy,rect.sw,rect.sh, 0,0, gridW,gridH);

  // UI 覆盖层尺寸与底图一致（用于画播放指示线）
  ui.width=gridW; ui.height=gridH;
}

/* 实时取景：达标即锁定一次，随后只显示静态谱图（不再叠加第二层截图） */
async function loop(){
  if(locked) return;
  const W=capCv.width,H=capCv.height;
  capCtx.drawImage(cam,0,0,W,H);
  const img=capCtx.getImageData(0,0,W,H);
  const rect=findBlackRect(img,W,H);

  if(rect && sameRect(rect,lastRect)){ stableCnt++; } else { stableCnt=0; }
  lastRect=rect;

  if(rect){
    frame.className = (stableCnt>18) ? 'green' : 'white pulse';
    if(stableCnt>18){
      locked=true;
      grabSpectroCanvas(rect);
      // 隐藏相机，只保留谱图与播放线
      cam.style.display='none';
      spec.style.display='block';
      ui.style.display='block';
      // 开始重建并自动播放
      prepareAndPlayFromSpecCanvas();
      return;
    }
  }else{
    frame.className = 'white pulse';
  }
  requestAnimationFrame(loop);
}

/* ===== 频谱取样 → Griffin-Lim 复原 ===== */
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
function sampleMFromCanvas(cv){
  const ctx=cv.getContext('2d',{willReadFrequently:true});
  const W=cv.width,H=cv.height, data=ctx.getImageData(0,0,W,H).data;
  const T = Math.max(16, Math.round((W - 2*MARGIN)/CELLX));
  const M=new Float32Array(K*T);
  for(let t=0;t<T;t++){
    for(let r=0;r<K;r++){
      const cx=MARGIN + t*CELLX + (CELLX>>1);
      const cy=MARGIN + (K-1-r)*CELLY + (CELLY>>1);
      const idx=(cy*W+cx)*4;
      const lum=0.2126*data[idx]+0.7152*data[idx+1]+0.0722*data[idx+2];
      const norm=clamp(1 - lum/255, 0, 1);
      const db=DBMIN + norm*(0-DBMIN);
      M[t*K+r] = Math.pow(10, db/20);
    }
  }
  return {M,T};
}
function hann(N){ const w=new Float32Array(N); for(let n=0;n<N;n++) w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); return w; }
const WIN=hann(NFFT);
function makeFFT(N){
  if(N&(N-1)) throw new Error('N must be pow2');
  const cos=new Float32Array(N/2),sin=new Float32Array(N/2);
  for(let i=0;i<N/2;i++){ const a=-2*Math.PI*i/N; cos[i]=Math.cos(a); sin[i]=Math.sin(a); }
  const rev=new Uint32Array(N); let b=0; while((1<<b)<N) b++;
  for(let i=0;i<N;i++){ let x=i,y=0; for(let j=0;j<b;j++){ y=(y<<1)|(x&1); x>>=1; } rev[i]=y; }
  function fft(re,im){
    for(let i=0;i<N;i++){ const j=rev[i]; if(j>i){ let t=re[i]; re[i]=re[j]; re[j]=t; t=im[i]; im[i]=im[j]; im[j]=t; } }
    for(let len=2; len<=N; len<<=1){ const h=len>>>1, step=N/len;
      for(let i=0;i<N;i+=len) for(let k=0;k<h;k++){
        const c=cos[k*step], s=sin[k*step], j=i+k, l=j+h;
        const r=c*re[l]-s*im[l], ii=s*re[l]+c*im[l];
        re[l]=re[j]-r; im[l]=im[j]-ii; re[j]+=r; im[j]+=ii;
      }
    }
  }
  function ifft(re,im){ for(let i=0;i<N;i++) im[i]=-im[i]; fft(re,im); const inv=1/N; for(let i=0;i<N;i++){ re[i]*=inv; im[i]*=-im[i]; } }
  return {fft,ifft};
}
const FFT=makeFFT(NFFT);

async function griffinLimAsync(M, T, iter=16){
  const K=M.length/T, N=NFFT;
  const re=new Float32Array(N), im=new Float32Array(N);
  const re2=new Float32Array(N), im2=new Float32Array(N);
  const phase=new Float32Array(K*T); for(let i=0;i<phase.length;i++) phase[i]=Math.random()*2*Math.PI;
  const L=(T-1)*HOP + N; const y=new Float32Array(L);
  for(let it=0; it<iter; it++){
    y.fill(0);
    for(let t=0;t<T;t++){
      for(let k=0;k<K;k++){ const mag=M[t*K+k]; re[k]=mag*Math.cos(phase[t*K+k]); im[k]=mag*Math.sin(phase[t*K+k]); }
      for(let k=K;k<N;k++){ re[k]=0; im[k]=0; }
      for(let k=1;k<K-1;k++){ re[N-k]=re[k]; im[N-k]=-im[k]; }
      FFT.ifft(re,im);
      const off=t*HOP; for(let n=0;n<N;n++) y[off+n]+=re[n]*WIN[n];
    }
    if(it<iter-1){
      for(let t=0;t<T;t++){
        const off=t*HOP; for(let n=0;n<N;n++){ re2[n]=(y[off+n]||0)*WIN[n]; im2[n]=0; }
        FFT.fft(re2,im2); for(let k=0;k<K;k++) phase[t*K+k]=Math.atan2(im2[k],re2[k]);
      }
    }
    await new Promise(r=>setTimeout(r,0)); // 让 UI 不卡
  }
  // 轻限幅
  let peak=1e-9; for(let i=0;i<y.length;i++) peak=Math.max(peak,Math.abs(y[i]));
  const g=0.9/peak; for(let i=0;i<y.length;i++) y[i]=Math.tanh(y[i]*g);
  return y;
}

/* ===== 自动播放（原速循环） + 播放指示线 ===== */
let actx=null, buffer=null, source=null, startTime=0, startOffset=0, durSec=0;
function stopSource(){ try{ source && source.stop(0); }catch(_){} source=null; }

async function prepareAndPlayFromSpecCanvas(){
  const {M,T} = sampleMFromCanvas(spec);
  const y = await griffinLimAsync(M,T,16);
  durSec = y.length / SR;

  // WebAudio
  if(!actx) actx = new (window.AudioContext||window.webkitAudioContext)({sampleRate:SR});

  const buf = actx.createBuffer(1, y.length, SR);
  buf.getChannelData(0).set(y);
  buffer = buf;

  // 尝试自动播放
  const ok = await ensureAudioAllowed();
  if(ok) playFrom(0); else showToast();
  // 开始画播放指示线
  drawPlayhead();
}

function playFrom(offsetSec){
  stopSource();
  source = actx.createBufferSource();
  source.buffer = buffer;
  source.loop = true;
  source.connect(actx.destination);
  startOffset = offsetSec%durSec;
  startTime = actx.currentTime;
  source.start(0, startOffset);
}

async function ensureAudioAllowed(){
  if(!actx) return false;
  if(actx.state === 'suspended'){
    try{ await actx.resume(); }catch(_){}
  }
  return actx.state === 'running';
}
function showToast(){ toast.style.display='block'; }
function hideToast(){ toast.style.display='none'; }

document.addEventListener('pointerdown', async ()=>{
  if(buffer && (await ensureAudioAllowed()) && !source){
    hideToast(); playFrom(startOffset||0);
  }
},{once:false});

/* 点击/拖动跳转 */
let dragging=false;
function canvasXToTime(x){
  const rect=spec.getBoundingClientRect();
  const px = clamp(x-rect.left, 0, rect.width);
  const ratio = px / rect.width;
  return ratio * durSec;
}
function onDown(e){
  if(!buffer) return;
  dragging=true;
  const x = (e.touches? e.touches[0].clientX : e.clientX);
  hideToast();
  ensureAudioAllowed().then(ok=>{
    if(!ok) return;
    const t = canvasXToTime(x);
    playFrom(t);
  });
}
function onMove(e){
  if(!dragging || !buffer) return;
  const x = (e.touches? e.touches[0].clientX : e.clientX);
  const t = canvasXToTime(x);
  playFrom(t);
}
function onUp(){ dragging=false; }
ui.addEventListener('pointerdown', onDown, {passive:true});
ui.addEventListener('pointermove', onMove, {passive:true});
ui.addEventListener('pointerup', onUp, {passive:true});
ui.addEventListener('touchstart', onDown, {passive:true});
ui.addEventListener('touchmove', onMove, {passive:true});
ui.addEventListener('touchend', onUp, {passive:true});

/* 播放指示线 */
function drawPlayhead(){
  if(!buffer){ requestAnimationFrame(drawPlayhead); return; }
  const ctx = ui.getContext('2d');
  const rect = ui.getBoundingClientRect();
  ui.width = spec.width; ui.height = spec.height; // 与底图像素对齐
  const now = actx ? actx.currentTime : 0;
  const t = source ? ((now - startTime + startOffset) % durSec) : (startOffset||0);
  const x = Math.round((t/durSec) * ui.width);

  // 清屏 & 画竖线
  ctx.clearRect(0,0,ui.width,ui.height);
  ctx.strokeStyle='rgba(255,255,255,.9)';
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,ui.height); ctx.stroke();

  requestAnimationFrame(drawPlayhead);
}

/* 启动 */
(async ()=>{
  try{
    await startCam();
    loop();
  }catch(e){
    alert("相机启动失败：请在 HTTPS（如 GitHub Pages）下访问并允许相机权限。");
  }
})();
</script>
</body>
</html>
